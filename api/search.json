[{"id":"b429fe05dd9f03c8ac0682ef266c3c0f","title":"----------使用手册","content":"序言Lombok是一款 Java 开发插件，使得 Java 开发者可以通过其定义的一些注解来消除业务工程中冗长和繁琐的代码\n常用注解解析@Data@Data是一个快捷注解，包含@Getter, @Setter, @ToString, @EqualsAndHashCode and @RequiredArgsConstructor注解。当@Data设置于类上时，将自动生成Getter、Setter、ToString、Equals、HashCode方法和默认构造器。\n例如\nimport lombok.AccessLevel;\nimport lombok.Setter;\nimport lombok.Data;\nimport lombok.ToString;\n\n@Data \npublic class DataExample &#123;\n  private String name;\n&#125;\n\n编译后的实体类\npublic class DataExample &#123;\n  private String name;\n\n  \n  public String getName() &#123;\n    return this.name;\n  &#125;\n\n  public String setName(String name) &#123;\n    return this.name &#x3D; name;\n  &#125;\n  \n  @Override \n  public String toString() &#123;\n    return &quot;DataExample(&quot; + this.getName() &quot;)&quot;;\n  &#125;\n  \n  @Override \n  public boolean equals(Object o) &#123;\n    if (o &#x3D;&#x3D; this) return true;\n    if (!(o instanceof DataExample)) return false;\n    DataExample other &#x3D; (DataExample) o;\n    if (!other.canEqual((Object)this)) return false;\n    if (this.getName() &#x3D;&#x3D; null ? other.getName() !&#x3D; null : !this.getName().equals(other.getName())) return false;\n    return true;\n  &#125;\n  \n  @Override \n  public int hashCode() &#123;\n    final int PRIME &#x3D; 59;\n    int result &#x3D; 1;\n    result &#x3D; (result*PRIME) + (this.getName() &#x3D;&#x3D; null ? 43 : this.getName().hashCode());\n    return result;\n  &#125;\n&#125;\n\n\n@Getter and @Setter，当为某一字段设置@Getter、@Setter注解时将自动生成此字段的Getter、Setter方法。当为某实体类设置@Getter、@Setter注解时，相当于为类中所有非静态字段设置@Getter、@Setter注解。\n例如\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class GetterSetterExample &#123;\n  private int age &#x3D; 10;\n&#125;\n编译后的实体类\npublic class GetterSetterExample &#123;\n    public int getAge() &#123;\n      return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n      this.age &#x3D; age;\n    &#125;\n&#125;\n\n\n@NoArgsConstructor 、@RequiredArgsConstructor、@AllArgsConstructor 构造器注解@NoArgsConstructor 将生成一个没有参数的构造函数，如果有final字段需使用@NoArgsConstructor(force = true)初始化@AllArgsConstructor 为类中的每个字段生成一个带有 1 个参数的构造函数。标注@NonNull参数会进行空检查。@RequiredArgsConstructor 生成构造包含所有必须字段的参数，包括含@NotNull注解的字段并做空检查，和final修饰且未初始化的字段。\n例如\nimport lombok.AccessLevel;\nimport lombok.RequiredArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport lombok.NonNull;\n\n@RequiredArgsConstructor(staticName &#x3D; &quot;of&quot;)\n@AllArgsConstructor(access &#x3D; AccessLevel.PROTECTED)\npublic class ConstructorExample&lt;T&gt; &#123;\n  private int x, y;\n  @NonNull private T description;\n  \n  @NoArgsConstructor\n  public static class NoArgsExample &#123;\n    @NonNull private String field;\n  &#125;\n&#125;\n\n编译后的实体类\npublic class ConstructorExample&lt;T&gt; &#123;\n  private int x, y;\n  @NonNull private T description;\n  \n  private ConstructorExample(T description) &#123;\n    if (description &#x3D;&#x3D; null) throw new NullPointerException(&quot;description&quot;);\n    this.description &#x3D; description;\n  &#125;\n  \n  public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) &#123;\n    return new ConstructorExample&lt;T&gt;(description);\n  &#125;\n  \n  @java.beans.ConstructorProperties(&#123;&quot;x&quot;, &quot;y&quot;, &quot;description&quot;&#125;)\n  protected ConstructorExample(int x, int y, T description) &#123;\n    if (description &#x3D;&#x3D; null) throw new NullPointerException(&quot;description&quot;);\n    this.x &#x3D; x;\n    this.y &#x3D; y;\n    this.description &#x3D; description;\n  &#125;\n  \n  public static class NoArgsExample &#123;\n    @NonNull private String field;\n    \n    public NoArgsExample() &#123;\n    &#125;\n  &#125;\n&#125;\n@EqualsAndHashCode任何类定义都可以用注释@EqualsAndHashCode来让Lombok生成equals(Object other)和hashCode()方法的实现。例如\nimport lombok.EqualsAndHashCode;\n\n@EqualsAndHashCode\npublic class EqualsAndHashCodeExample &#123;\n  private transient int transientVar &#x3D; 10;\n  private String name;\n  private double score;\n  @EqualsAndHashCode.Exclude private Shape shape &#x3D; new Square(5, 10);\n  private String[] tags;\n  @EqualsAndHashCode.Exclude private int id;\n  \n  public String getName() &#123;\n    return this.name;\n  &#125;\n  \n  @EqualsAndHashCode(callSuper&#x3D;true)\n  public static class Square extends Shape &#123;\n    private final int width, height;\n    \n    public Square(int width, int height) &#123;\n      this.width &#x3D; width;\n      this.height &#x3D; height;\n    &#125;\n  &#125;\n&#125;\n编译后的实体类\nimport java.util.Arrays;\n\npublic class EqualsAndHashCodeExample &#123;\n  private transient int transientVar &#x3D; 10;\n  private String name;\n  private double score;\n  private Shape shape &#x3D; new Square(5, 10);\n  private String[] tags;\n  private int id;\n  \n  public String getName() &#123;\n    return this.name;\n  &#125;\n  \n  @Override public boolean equals(Object o) &#123;\n    if (o &#x3D;&#x3D; this) return true;\n    if (!(o instanceof EqualsAndHashCodeExample)) return false;\n    EqualsAndHashCodeExample other &#x3D; (EqualsAndHashCodeExample) o;\n    if (!other.canEqual((Object)this)) return false;\n    if (this.getName() &#x3D;&#x3D; null ? other.getName() !&#x3D; null : !this.getName().equals(other.getName())) return false;\n    if (Double.compare(this.score, other.score) !&#x3D; 0) return false;\n    if (!Arrays.deepEquals(this.tags, other.tags)) return false;\n    return true;\n  &#125;\n  \n  @Override public int hashCode() &#123;\n    final int PRIME &#x3D; 59;\n    int result &#x3D; 1;\n    final long temp1 &#x3D; Double.doubleToLongBits(this.score);\n    result &#x3D; (result*PRIME) + (this.name &#x3D;&#x3D; null ? 43 : this.name.hashCode());\n    result &#x3D; (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32));\n    result &#x3D; (result*PRIME) + Arrays.deepHashCode(this.tags);\n    return result;\n  &#125;\n  \n  protected boolean canEqual(Object other) &#123;\n    return other instanceof EqualsAndHashCodeExample;\n  &#125;\n  \n  public static class Square extends Shape &#123;\n    private final int width, height;\n    \n    public Square(int width, int height) &#123;\n      this.width &#x3D; width;\n      this.height &#x3D; height;\n    &#125;\n    \n    @Override public boolean equals(Object o) &#123;\n      if (o &#x3D;&#x3D; this) return true;\n      if (!(o instanceof Square)) return false;\n      Square other &#x3D; (Square) o;\n      if (!other.canEqual((Object)this)) return false;\n      if (!super.equals(o)) return false;\n      if (this.width !&#x3D; other.width) return false;\n      if (this.height !&#x3D; other.height) return false;\n      return true;\n    &#125;\n    \n    @Override public int hashCode() &#123;\n      final int PRIME &#x3D; 59;\n      int result &#x3D; 1;\n      result &#x3D; (result*PRIME) + super.hashCode();\n      result &#x3D; (result*PRIME) + this.width;\n      result &#x3D; (result*PRIME) + this.height;\n      return result;\n    &#125;\n    \n    protected boolean canEqual(Object other) &#123;\n      return other instanceof Square;\n    &#125;\n  &#125;\n&#125;\n@NonNull您可以@NonNull在字段、方法、构造函数的参数上使用。这将导致Lombok为您生成一个空检查语句\n\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something &#123;\n  private String name;\n  \n  public NonNullExample(@NonNull Person person) &#123;\n    super(&quot;Hello&quot;);\n    this.name &#x3D; person.getName();\n  &#125;\n&#125;\n编译后的实体类\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something &#123;\n  private String name;\n  \n  public NonNullExample(@NonNull Person person) &#123;\n    super(&quot;Hello&quot;);\n    if (person &#x3D;&#x3D; null) &#123;\n      throw new NullPointerException(&quot;person is marked non-null but is null&quot;);\n    &#125;\n    this.name &#x3D; person.getName();\n  &#125;\n&#125;\n@Log@LogLombok添加的多种变体，无论使用哪个，都将生成一个静态的final log字段，按照你使用的日志框架的通常规定的方式进行初始化，然后你可以使用它来编写日志语句。变体有@CommonsLog、@Flogger、@JBossLog、@Log、@Log4j、@Log4j2、@Slf4j、@XSlf4j、@CustomLog。例如\n\nimport lombok.extern.java.Log;\nimport lombok.extern.slf4j.Slf4j;\n\n@Log\npublic class LogExample &#123;\n  \n  public static void main(String... args) &#123;\n    log.severe(&quot;Something&#39;s wrong here&quot;);\n  &#125;\n&#125;\n\n@Slf4j\npublic class LogExampleOther &#123;\n  \n  public static void main(String... args) &#123;\n    log.error(&quot;Something else is wrong here&quot;);\n  &#125;\n&#125;\n\n@CommonsLog(topic&#x3D;&quot;CounterLog&quot;)\npublic class LogExampleCategory &#123;\n\n  public static void main(String... args) &#123;\n    log.error(&quot;Calling the &#39;CounterLog&#39; with a message&quot;);\n  &#125;\n&#125;\n编译后的实体类\npublic class LogExample &#123;\n  private static final java.util.logging.Logger log &#x3D; java.util.logging.Logger.getLogger(LogExample.class.getName());\n  \n  public static void main(String... args) &#123;\n    log.severe(&quot;Something&#39;s wrong here&quot;);\n  &#125;\n&#125;\n\npublic class LogExampleOther &#123;\n  private static final org.slf4j.Logger log &#x3D; org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);\n  \n  public static void main(String... args) &#123;\n    log.error(&quot;Something else is wrong here&quot;);\n  &#125;\n&#125;\n\npublic class LogExampleCategory &#123;\n  private static final org.apache.commons.logging.Log log &#x3D; org.apache.commons.logging.LogFactory.getLog(&quot;CounterLog&quot;);\n\n  public static void main(String... args) &#123;\n    log.error(&quot;Calling the &#39;CounterLog&#39; with a message&quot;);\n  &#125;\n&#125;\n\n\n","slug":"Lombok的使用","date":"2022-05-18T14:14:06.000Z","categories_index":"Lombok","tags_index":"Lombok","author_index":"如峰"},{"id":"91e0f6f330b5dca608acfed732198bf6","title":"JavaScript代码技巧","content":"变量的声明var、const、let的区别\n\n\n表头\nvar\nlet\nconst\n\n\n\n定义常量\n\n\n√\n\n\n定义变量\n√\n√\n\n\n\n可被释放\n√\n√\n√\n\n\n可被提升\n√\n\n\n\n\n重复定义检查\n\n√\n√\n\n\n可用于块级作用域\n\n√\n√\n\n\n多行变量声明的优化let name &#x3D; 1;  &#x2F;&#x2F; 名称\nlet age &#x3D; 2;   &#x2F;&#x2F; 年龄\nlet classes &#x3D; 3; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\n\n&#x2F;&#x2F; 名称 年龄 班级\nlet [name, age, classes] &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 特别多的变量,当需要换行时的格式\nlet [name, age, classes]\n    &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 此方式默认值的设置,myClasses默认值设置3\nlet [name, age, myClasses]\n    &#x3D; [1, 2, class || 3];\n\n&#x2F;&#x2F; 声明三个都是undefined的变量\nlet [name, age, myClasses] &#x3D; [];\n&#x2F;&#x2F; 声明三个都是空的变量 \nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(4).join(&#39;0&#39;).split(&#39;&#39;);\n\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(3).fill(0);\nlet [name, age, myClasses] &#x3D; Array.from(&#123;length: 3&#125;).map(()&#x3D;&gt; 0)\n\n\n数组取值的优化let arr &#x3D; [1, 2, 3];\nlet arr1 &#x3D; arr[0];\nlet arr2 &#x3D; arr[1];\nlet arr3 &#x3D; arr[2];\n\n&#x2F;&#x2F; 优化后\nlet arr &#x3D; [1, 2, 3];\nlet [arr1, arr2, arr3] &#x3D; arr;\n\n对象取值的优化let student &#x3D; &#123;name:1, age:2, classes:3&#125;;\nlet name &#x3D; student.name;   &#x2F;&#x2F; 名称\nlet age &#x3D; student.age;     &#x2F;&#x2F; 年龄\nlet class &#x3D; student.classes; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet &#123;name : name, age : age, classes : classes&#125; &#x3D; student;\n&#x2F;&#x2F; 变量与属性名不相同 (key : value) key:JSON对象的属性名 value:变量名\nlet &#123;name : myName, age : myAge, classes : myClasses&#125; &#x3D; student;\n&#x2F;&#x2F; 此种对象的默认值设置仅在等于undefined的时候触发Myclasses &#x3D; 0\nlet &#123;name : myName, age : myAge, classes : myClasses &#x3D; 0&#125; &#x3D; student;\n \nlet &#123;name , age , classes&#125; &#x3D; student;\n\n\n逻辑与 &amp;&amp; 、逻辑或 || 的使用在使用之前我们要理解逻辑与和逻辑或的重要特性,短路.逻辑与: 当前面为假时,则直接返回假,否则返回后面的结果逻辑或: 当前面为真时,则直接返回真,否则返回后面的结果\n默认值的优化&#x2F;&#x2F; myName默认值的优化\nlet name &#x3D; 1;\nif (name) &#123;\n    let myName &#x3D; name;\n&#125; else &#123;\n    let myName &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet name &#x3D; 1;\nlet myName &#x3D; name || 2;\n&#x2F;&#x2F; 扩展:我们在函数调用时设置默认值\ngetName(myName || name);\n\n\n单行if语句的优化&#x2F;&#x2F; 单行if语句的优化\nif(name)&#123; console.log(name)&#125;\n\n&#x2F;&#x2F; 优化后\nname &amp;&amp; console.log(name);\n\n\n取非空对象值的优化&#x2F;&#x2F; 取非空JSON值的优化\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\n\n&#x2F;&#x2F; student与student在代码逻辑中,只有一个有值,且我们要取出这个name,优先取student\nlet name &#x3D; null;\nif (student) &#123;\n    name &#x3D; student.name;\n&#125; else if(student1) &#123;\n    name &#x3D; student1.name;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\nlet name &#x3D; (student || student1)[&#39;name&#39;];\n&#x2F;&#x2F; 或者\nlet name &#x3D; (student || student1).name;\n\n\nJSON的使用JSON声明的优化let student &#x3D; &#123;&#125;;\nlet classes &#x3D; 2;\nstudent.name &#x3D; 1;\nstudent.classes &#x3D; classes || 3;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; 2;\nlet student &#x3D; &#123;\n    name : 1,\n    classes : classes || 3,\n&#125;;\n\n\nJSON取值的优化let student &#x3D; &#123;\n    name : 1,\n    classes1 : null,\n    classes2 : 3,\n&#125;;\n&#x2F;&#x2F; 当classes1为空时取classes2\nlet classes &#x3D; null;\nif (student.classes1) &#123;\n    classes &#x3D; student.classes1;\n&#125; else &#123;\n    classes &#x3D; student.classes2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; student.classes1 || student.classes2;\nlet classes &#x3D; student[&quot;classes1&quot;] || student[&#39;classes2&quot;];\n\n\n条件运算符的使用if else 语句的优化let method &#x3D; request.method;\nif (method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n    let name &#x3D; request.getValue(&quot;name&quot;);\n&#125; else &#123;\n    let name &#x3D; request.getValue(&quot;custpage_name&quot;);\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet method &#x3D; request.method;\nlet name &#x3D; request.getValue(method &#x3D;&#x3D; &#39;GET&#39; ? &quot;name&quot; : &quot;custpage_name&quot;);\nlet name &#x3D; method &#x3D;&#x3D; &#39;GET&#39; ? request.getValue(&quot;name&quot;) : request.getValue(&quot;custpage_name&quot;);\n\n\n方法调用的优化let isUp &#x3D; false;\nif (isUp)&#123;\n    up();\n&#125; else &#123;\n    down();\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet isUp &#x3D; false;\nisUp ? up() : down();\n&#x2F;&#x2F; 或者在函数的返回值使用条件运算符\nfunction jump(isUp)&#123;\n    return isUp ? up() : down();\n&#125;\n\n其它链式调用var form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;);\nhtmlHeader.updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;);\nhtmlHeader.updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;);\nhtmlHeader.defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n\n&#x2F;&#x2F; 链式调用\nvar form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;).updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;).updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;).defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n\n字符串拼接let n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\n\nlet string &#x3D; n + &quot;-&quot; + b + &quot;-&quot; + s + &quot;-&quot; + y;\nlet string2 &#x3D; n + b + s + y;\n\n&#x2F;&#x2F; 优化后\nlet n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\nlet string &#x3D; [n, b ,s,y].join(&quot;-&quot;);\nlet string2 &#x3D; n.concat(b, s, y);\n\n&#x2F;&#x2F; 字符串拼接其他方式\nlet string &#x3D; &quot;a-b-c-y&quot;;\nstring &#x3D; string.replace(&quot;a&quot;,a).replace(&quot;b&quot;,b).replace(&quot;b&quot;,b).replace(&quot;y&quot;,y);\n\n包含判断let a &#x3D; 1;\nif(a &#x3D;&#x3D; 1 || a &#x3D;&#x3D; 2 || a &#x3D;&#x3D; 3)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n    \n&#x2F;&#x2F; 优化\nif([1, 2, 3].indexof(a) &gt;&#x3D; 0)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n\n\n数组的简写方式let a &#x3D; new Array();\n\n&#x2F;&#x2F; 简写\nlet a &#x3D; [];\n\n箭头函数箭头函数就是函数的简写方式\nfunction doSomething(a, b)&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 以下仅仅@NApiVersion 2.0以上可以使用\n&#x2F;&#x2F; 简写\nlet doSomething &#x3D; (a, b) &#x3D;&gt; &#123;return a + b;&#125;;\n\n&#x2F;&#x2F; 箭头函数的两个省略\n&#x2F;&#x2F; 1.当箭头左边只有一个参数时,可省略()\na &#x3D;&gt; &#123;return a + 1;&#125;;\n&#x2F;&#x2F; 2.当箭头右边只有一句话时,可省略&#123;&#125;与return\n(a, b) &#x3D;&gt; a + b;\n\n对象的keys、values的使用let student &#x3D; &#123;\n    name : 1,\n    classes : 3,\n&#125;;\n\n&#x2F;&#x2F; 获取对象的Keys\nObject.keys(student);   &#x2F;&#x2F; expected output: [&quot;name&quot;, &quot;classes&quot;]\n&#x2F;&#x2F; 获取对象的values\nObject.values(student); &#x2F;&#x2F; expected output: [1, 3]\n\n&#x2F;&#x2F; 判断对象是否具有该属性\nstudent.hasOwnProperty(&quot;classes&quot;);\nObject.keys(student).indexof(&quot;name&quot;) &gt;&#x3D; 0;\n\n\n数组的常用函数 &#x2F;&#x2F; filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 \nconst words &#x3D; [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];\nconst result &#x3D; words.filter(word &#x3D;&gt; word.length &gt; 6);\nconsole.log(result);             &#x2F;&#x2F; expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]\n\n&#x2F;&#x2F; find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。\nconst array1 &#x3D; [5, 12, 8, 130, 44];\nconst found &#x3D; array1.find(element &#x3D;&gt; element &gt; 10);\nconsole.log(found);              &#x2F;&#x2F; expected output: 12\n\n&#x2F;&#x2F; forEach() 方法对数组的每个元素执行一次给定的函数。\nconst array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\narray1.forEach(element &#x3D;&gt; console.log(element));\n\n&#x2F;&#x2F; includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。\nconst array1 &#x3D; [1, 2, 3];\nconsole.log(array1.includes(2));   &#x2F;&#x2F; expected output: true\nconst pets &#x3D; [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;];\nconsole.log(pets.includes(&#39;cat&#39;)); &#x2F;&#x2F; expected output: true\nconsole.log(pets.includes(&#39;at&#39;));  &#x2F;&#x2F; expected output: false\n\n&#x2F;&#x2F; map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\nconst array1 &#x3D; [1, 4, 9, 16];     &#x2F;&#x2F; pass a function to map\nconst map1 &#x3D; array1.map(x &#x3D;&gt; x * 2);\nconsole.log(map1);                &#x2F;&#x2F; expected output: Array [2, 8, 18, 32]\n\n&#x2F;&#x2F; reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nconst array1 &#x3D; [1, 2, 3, 4];\nconst reducer &#x3D; (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue; \n&#x2F;&#x2F; 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer));                                       &#x2F;&#x2F; expected output: 10\n&#x2F;&#x2F; 5 + 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer, 5));                                    &#x2F;&#x2F; expected output: 15\n这些方法是ES6以上可以使用,但是我们想在ES6以下运用这些方法时,只需按照网址:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Array找到对应函数polyfill复制粘贴就能使用.\n字符串常用方法&#x2F;&#x2F; padEnd()  方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\n&#39;abc&#39;.padEnd(10);          &#x2F;&#x2F; &quot;abc       &quot;\n&#39;abc&#39;.padEnd(10, &quot;foo&quot;);   &#x2F;&#x2F; &quot;abcfoofoof&quot;\n&#39;abc&#39;.padEnd(6, &quot;123456&quot;); &#x2F;&#x2F; &quot;abc123&quot;\n&#39;abc&#39;.padEnd(1);           &#x2F;&#x2F; &quot;abc&quot;\n\n&#x2F;&#x2F; padStart() 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。\n&#39;abc&#39;.padStart(10);         &#x2F;&#x2F; &quot;       abc&quot;\n&#39;abc&#39;.padStart(10, &quot;foo&quot;);  &#x2F;&#x2F; &quot;foofoofabc&quot;\n&#39;abc&#39;.padStart(6,&quot;123465&quot;); &#x2F;&#x2F; &quot;123abc&quot;\n&#39;abc&#39;.padStart(8, &quot;0&quot;);     &#x2F;&#x2F; &quot;00000abc&quot;\n&#39;abc&#39;.padStart(1);          &#x2F;&#x2F; &quot;abc&quot;\n这些方法注意事项同上.\n优化的注意事项在优化之前我们要理解为什么要优化代码,所有的优化都是为了代码的可读性,但在某些情况下以上的例子不优化可能比优化的可读性要好例如 \n&#x2F;&#x2F; 声明三个都是空的变量 \nlet name &#x3D; null;    &#x2F;&#x2F; 名称\nlet age &#x3D; null;     &#x2F;&#x2F; 年龄\nlet classes &#x3D; null; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n\n难道上面name, age, classes的声明方式比下面的优化语句,可读性差吗?并没有,但是当声明10个、20个、30个以上空的变量时,下面的优化语句就比上面的可读性强.当我们发现优化后并没有对可读性有提升时,就没必要优化.不过我们依然需要了解这些优化方式,以免我们需要增加代码可读性的时候,无从下手,或者不理解别人的代码.可读性不强的代码千千万万,优化的方式也多种多样,我们应当不放过自己可读性不强的代码,记住别人好的优化方式.各位还有别的案例或者优化方式,都可以自己更新这个文档,分享出来.\n网址的分享Javascript教程:https://wangdoc.com/javascript/index.htmlJS编程规范:https://github.com/airbnb/javascript/tree/es5-deprecated/es5ECMAScript6入门:https://es6.ruanyifeng.com/?search=%E7%AE%AD%E5%A4%B4&x=0&y=0JavaScript帮助文档:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_ObjectswebStorm激活码获取:http://idea.94goo.com/\n","slug":"JavaScript","date":"2022-05-16T15:05:06.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"如峰"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n","slug":"hello-world","date":"2022-05-13T15:11:03.907Z","categories_index":"","tags_index":"","author_index":"如峰"}]