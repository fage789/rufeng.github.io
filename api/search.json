[{"id":"91e0f6f330b5dca608acfed732198bf6","title":"JavaScript代码技巧","content":"变量的声明var、const、let的区别\n\n\n表头\nvar\nlet\nconst\n\n\n\n定义常量\n\n\n√\n\n\n定义变量\n√\n√\n\n\n\n可被释放\n√\n√\n√\n\n\n可被提升\n√\n\n\n\n\n重复定义检查\n\n√\n√\n\n\n可用于块级作用域\n\n√\n√\n\n\n多行变量声明的优化let name &#x3D; 1;  &#x2F;&#x2F; 名称\nlet age &#x3D; 2;   &#x2F;&#x2F; 年龄\nlet classes &#x3D; 3; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\n\n&#x2F;&#x2F; 名称 年龄 班级\nlet [name, age, classes] &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 特别多的变量,当需要换行时的格式\nlet [name, age, classes]\n    &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 此方式默认值的设置,myClasses默认值设置3\nlet [name, age, myClasses]\n    &#x3D; [1, 2, class || 3];\n\n&#x2F;&#x2F; 声明三个都是undefined的变量\nlet [name, age, myClasses] &#x3D; [];\n&#x2F;&#x2F; 声明三个都是空的变量 \nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(4).join(&#39;0&#39;).split(&#39;&#39;);\n\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(3).fill(0);\nlet [name, age, myClasses] &#x3D; Array.from(&#123;length: 3&#125;).map(()&#x3D;&gt; 0)\n\n\n数组取值的优化let arr &#x3D; [1, 2, 3];\nlet arr1 &#x3D; arr[0];\nlet arr2 &#x3D; arr[1];\nlet arr3 &#x3D; arr[2];\n\n&#x2F;&#x2F; 优化后\nlet arr &#x3D; [1, 2, 3];\nlet [arr1, arr2, arr3] &#x3D; arr;\n\n对象取值的优化let student &#x3D; &#123;name:1, age:2, classes:3&#125;;\nlet name &#x3D; student.name;   &#x2F;&#x2F; 名称\nlet age &#x3D; student.age;     &#x2F;&#x2F; 年龄\nlet class &#x3D; student.classes; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet &#123;name : name, age : age, classes : classes&#125; &#x3D; student;\n&#x2F;&#x2F; 变量与属性名不相同 (key : value) key:JSON对象的属性名 value:变量名\nlet &#123;name : myName, age : myAge, classes : myClasses&#125; &#x3D; student;\n&#x2F;&#x2F; 此种对象的默认值设置仅在等于undefined的时候触发Myclasses &#x3D; 0\nlet &#123;name : myName, age : myAge, classes : myClasses &#x3D; 0&#125; &#x3D; student;\n \nlet &#123;name , age , classes&#125; &#x3D; student;\n\n\n逻辑与 &amp;&amp; 、逻辑或 || 的使用在使用之前我们要理解逻辑与和逻辑或的重要特性,短路.逻辑与: 当前面为假时,则直接返回假,否则返回后面的结果逻辑或: 当前面为真时,则直接返回真,否则返回后面的结果\n默认值的优化&#x2F;&#x2F; myName默认值的优化\nlet name &#x3D; 1;\nif (name) &#123;\n    let myName &#x3D; name;\n&#125; else &#123;\n    let myName &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet name &#x3D; 1;\nlet myName &#x3D; name || 2;\n&#x2F;&#x2F; 扩展:我们在函数调用时设置默认值\ngetName(myName || name);\n\n\n单行if语句的优化&#x2F;&#x2F; 单行if语句的优化\nif(name)&#123; console.log(name)&#125;\n\n&#x2F;&#x2F; 优化后\nname &amp;&amp; console.log(name);\n\n\n取非空对象值的优化&#x2F;&#x2F; 取非空JSON值的优化\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\n\n&#x2F;&#x2F; student与student在代码逻辑中,只有一个有值,且我们要取出这个name,优先取student\nlet name &#x3D; null;\nif (student) &#123;\n    name &#x3D; student.name;\n&#125; else if(student1) &#123;\n    name &#x3D; student1.name;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\nlet name &#x3D; (student || student1)[&#39;name&#39;];\n&#x2F;&#x2F; 或者\nlet name &#x3D; (student || student1).name;\n\n\nJSON的使用JSON声明的优化let student &#x3D; &#123;&#125;;\nlet classes &#x3D; 2;\nstudent.name &#x3D; 1;\nstudent.classes &#x3D; classes || 3;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; 2;\nlet student &#x3D; &#123;\n    name : 1,\n    classes : classes || 3,\n&#125;;\n\n\nJSON取值的优化let student &#x3D; &#123;\n    name : 1,\n    classes1 : null,\n    classes2 : 3,\n&#125;;\n&#x2F;&#x2F; 当classes1为空时取classes2\nlet classes &#x3D; null;\nif (student.classes1) &#123;\n    classes &#x3D; student.classes1;\n&#125; else &#123;\n    classes &#x3D; student.classes2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; student.classes1 || student.classes2;\nlet classes &#x3D; student[&quot;classes1&quot;] || student[&#39;classes2&quot;];\n\n\n条件运算符的使用if else 语句的优化let method &#x3D; request.method;\nif (method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n    let name &#x3D; request.getValue(&quot;name&quot;);\n&#125; else &#123;\n    let name &#x3D; request.getValue(&quot;custpage_name&quot;);\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet method &#x3D; request.method;\nlet name &#x3D; request.getValue(method &#x3D;&#x3D; &#39;GET&#39; ? &quot;name&quot; : &quot;custpage_name&quot;);\nlet name &#x3D; method &#x3D;&#x3D; &#39;GET&#39; ? request.getValue(&quot;name&quot;) : request.getValue(&quot;custpage_name&quot;);\n\n\n方法调用的优化let isUp &#x3D; false;\nif (isUp)&#123;\n    up();\n&#125; else &#123;\n    down();\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet isUp &#x3D; false;\nisUp ? up() : down();\n&#x2F;&#x2F; 或者在函数的返回值使用条件运算符\nfunction jump(isUp)&#123;\n    return isUp ? up() : down();\n&#125;\n\n其它链式调用var form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;);\nhtmlHeader.updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;);\nhtmlHeader.updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;);\nhtmlHeader.defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n\n&#x2F;&#x2F; 链式调用\nvar form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;).updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;).updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;).defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n\n字符串拼接let n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\n\nlet string &#x3D; n + &quot;-&quot; + b + &quot;-&quot; + s + &quot;-&quot; + y;\nlet string2 &#x3D; n + b + s + y;\n\n&#x2F;&#x2F; 优化后\nlet n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\nlet string &#x3D; [n, b ,s,y].join(&quot;-&quot;);\nlet string2 &#x3D; n.concat(b, s, y);\n\n&#x2F;&#x2F; 字符串拼接其他方式\nlet string &#x3D; &quot;a-b-c-y&quot;;\nstring &#x3D; string.replace(&quot;a&quot;,a).replace(&quot;b&quot;,b).replace(&quot;b&quot;,b).replace(&quot;y&quot;,y);\n\n包含判断let a &#x3D; 1;\nif(a &#x3D;&#x3D; 1 || a &#x3D;&#x3D; 2 || a &#x3D;&#x3D; 3)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n    \n&#x2F;&#x2F; 优化\nif([1, 2, 3].indexof(a) &gt;&#x3D; 0)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n\n\n数组的简写方式let a &#x3D; new Array();\n\n&#x2F;&#x2F; 简写\nlet a &#x3D; [];\n\n箭头函数箭头函数就是函数的简写方式\nfunction doSomething(a, b)&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 以下仅仅@NApiVersion 2.0以上可以使用\n&#x2F;&#x2F; 简写\nlet doSomething &#x3D; (a, b) &#x3D;&gt; &#123;return a + b;&#125;;\n\n&#x2F;&#x2F; 箭头函数的两个省略\n&#x2F;&#x2F; 1.当箭头左边只有一个参数时,可省略()\na &#x3D;&gt; &#123;return a + 1;&#125;;\n&#x2F;&#x2F; 2.当箭头右边只有一句话时,可省略&#123;&#125;与return\n(a, b) &#x3D;&gt; a + b;\n\n对象的keys、values的使用let student &#x3D; &#123;\n    name : 1,\n    classes : 3,\n&#125;;\n\n&#x2F;&#x2F; 获取对象的Keys\nObject.keys(student);   &#x2F;&#x2F; expected output: [&quot;name&quot;, &quot;classes&quot;]\n&#x2F;&#x2F; 获取对象的values\nObject.values(student); &#x2F;&#x2F; expected output: [1, 3]\n\n&#x2F;&#x2F; 判断对象是否具有该属性\nstudent.hasOwnProperty(&quot;classes&quot;);\nObject.keys(student).indexof(&quot;name&quot;) &gt;&#x3D; 0;\n\n\n数组的常用函数 &#x2F;&#x2F; filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 \nconst words &#x3D; [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];\nconst result &#x3D; words.filter(word &#x3D;&gt; word.length &gt; 6);\nconsole.log(result);             &#x2F;&#x2F; expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]\n\n&#x2F;&#x2F; find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。\nconst array1 &#x3D; [5, 12, 8, 130, 44];\nconst found &#x3D; array1.find(element &#x3D;&gt; element &gt; 10);\nconsole.log(found);              &#x2F;&#x2F; expected output: 12\n\n&#x2F;&#x2F; forEach() 方法对数组的每个元素执行一次给定的函数。\nconst array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\narray1.forEach(element &#x3D;&gt; console.log(element));\n\n&#x2F;&#x2F; includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。\nconst array1 &#x3D; [1, 2, 3];\nconsole.log(array1.includes(2));   &#x2F;&#x2F; expected output: true\nconst pets &#x3D; [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;];\nconsole.log(pets.includes(&#39;cat&#39;)); &#x2F;&#x2F; expected output: true\nconsole.log(pets.includes(&#39;at&#39;));  &#x2F;&#x2F; expected output: false\n\n&#x2F;&#x2F; map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\nconst array1 &#x3D; [1, 4, 9, 16];     &#x2F;&#x2F; pass a function to map\nconst map1 &#x3D; array1.map(x &#x3D;&gt; x * 2);\nconsole.log(map1);                &#x2F;&#x2F; expected output: Array [2, 8, 18, 32]\n\n&#x2F;&#x2F; reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nconst array1 &#x3D; [1, 2, 3, 4];\nconst reducer &#x3D; (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue; \n&#x2F;&#x2F; 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer));                                       &#x2F;&#x2F; expected output: 10\n&#x2F;&#x2F; 5 + 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer, 5));                                    &#x2F;&#x2F; expected output: 15\n这些方法是ES6以上可以使用,但是我们想在ES6以下运用这些方法时,只需按照网址:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;Array找到对应函数polyfill复制粘贴就能使用.\n字符串常用方法&#x2F;&#x2F; padEnd()  方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\n&#39;abc&#39;.padEnd(10);          &#x2F;&#x2F; &quot;abc       &quot;\n&#39;abc&#39;.padEnd(10, &quot;foo&quot;);   &#x2F;&#x2F; &quot;abcfoofoof&quot;\n&#39;abc&#39;.padEnd(6, &quot;123456&quot;); &#x2F;&#x2F; &quot;abc123&quot;\n&#39;abc&#39;.padEnd(1);           &#x2F;&#x2F; &quot;abc&quot;\n\n&#x2F;&#x2F; padStart() 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。\n&#39;abc&#39;.padStart(10);         &#x2F;&#x2F; &quot;       abc&quot;\n&#39;abc&#39;.padStart(10, &quot;foo&quot;);  &#x2F;&#x2F; &quot;foofoofabc&quot;\n&#39;abc&#39;.padStart(6,&quot;123465&quot;); &#x2F;&#x2F; &quot;123abc&quot;\n&#39;abc&#39;.padStart(8, &quot;0&quot;);     &#x2F;&#x2F; &quot;00000abc&quot;\n&#39;abc&#39;.padStart(1);          &#x2F;&#x2F; &quot;abc&quot;\n这些方法注意事项同上.\n优化的注意事项在优化之前我们要理解为什么要优化代码,所有的优化都是为了代码的可读性,但在某些情况下以上的例子不优化可能比优化的可读性要好例如 \n&#x2F;&#x2F; 声明三个都是空的变量 \nlet name &#x3D; null;    &#x2F;&#x2F; 名称\nlet age &#x3D; null;     &#x2F;&#x2F; 年龄\nlet classes &#x3D; null; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n\n难道上面name, age, classes的声明方式比下面的优化语句,可读性差吗?并没有,但是当声明10个、20个、30个以上空的变量时,下面的优化语句就比上面的可读性强.当我们发现优化后并没有对可读性有提升时,就没必要优化.不过我们依然需要了解这些优化方式,以免我们需要增加代码可读性的时候,无从下手,或者不理解别人的代码.可读性不强的代码千千万万,优化的方式也多种多样,我们应当不放过自己可读性不强的代码,记住别人好的优化方式.各位还有别的案例或者优化方式,都可以自己更新这个文档,分享出来.\n网址的分享Javascript教程:https://wangdoc.com/javascript/index.htmlJS编程规范:https://github.com/airbnb/javascript/tree/es5-deprecated/es5ECMAScript6入门:https://es6.ruanyifeng.com/?search=%E7%AE%AD%E5%A4%B4&x=0&y=0JavaScript帮助文档:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_ObjectswebStorm激活码获取:http://idea.94goo.com/\n","slug":"JavaScript","date":"2022-05-16T15:05:06.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"如峰"}]