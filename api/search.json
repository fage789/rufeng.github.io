[{"id":"c89fcf3f80f5323c4d2b7488e0aabc7d","title":"Java文档注释","content":"","slug":"Java文档注释","date":"2022-06-07T10:30:06.000Z","categories_index":"java,注释","tags_index":"java,注释","author_index":"如峰"},{"id":"21734e1cbf39a356733db81c004c61e6","title":"Java Stream 流式编程","content":"引言\n流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，你无需写任何多线程代码了！\n流创建\n通过集合\n&#x2F;&#x2F; 创建一个集合\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n&#x2F;&#x2F; 得到一个顺序流\nStream&lt;Integer&gt; stream &#x3D; list.stream();\n&#x2F;&#x2F; 得到一个并行了流\nStream&lt;Integer&gt; parallelStream &#x3D; list.parallelStream();\n通过数组\n&#x2F;&#x2F; 先创建一个数组\nint[] arr &#x3D; new int[]&#123;1, 2, 3, 4, 5, 6&#125;;\n&#x2F;&#x2F; 使用数组Arrays工具类获取Stream流\nIntStream stream &#x3D; Arrays.stream(arr);\n通过of\nStream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5,6);\n创建无限流\n&#x2F;&#x2F; 无限流之迭代方式\n&#x2F;&#x2F; 创建了10个元素从0到18, 第一个参数是初始值、第二个参数决定下一个生成值的规则\nStream&lt;Integer&gt; streamI &#x3D;  Stream.iterate(0, t -&gt; t + 2).limit(10);\n        \n&#x2F;&#x2F; 无限流之生成方式\n&#x2F;&#x2F; 创建了10个随机数\nStream&lt;Double&gt; streamG &#x3D;  Stream.generate(Math::random).limit(10);\n构造器模式\nStream&lt;Integer&gt; stream &#x3D; Stream.&lt;Integer&gt;builder().add(1).add(2).build();\nstream.forEach(System.out::print);\n流的常用操作\n中间操作与终端操作\njava.util.stream.Stream中的Stream接口定义了许多操作。它们可以分为两大类。我们来看一下例子：\nList&lt;String&gt; names &#x3D; menu.stream() \n    .filter(d -&gt; d.getCalories() &gt; 300)\n    .map(Dish::getName) \n    .limit(3) \n    .collect(toList()); \n\n你可以看到两类操作：\n\nfilter、map和limit可以连成一条流水线；\ncollect触发流水线执行并关闭它。\n\n\n\n\n\n\n\n\n\n\n可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。\n\n\n\n\n\n\n\n警告\n使用终端操作代表消费流结束,想要重新消费必须重新构建流。\n\n\n常用操作API\n\n\n\n操作\n类型\n返回类型\n操作参数\n函数描述符\n功能描述\n\n\n\n\nfilter\n中间\nStream&lt;T&gt;\nPredicate&lt;T&gt;\nT -&gt; boolean\n过滤\n\n\ndistinct\n中间\nStream&lt;T&gt;\n\n\n去重\n\n\nskip\n中间\nStream&lt;T&gt;\nlong\n\n跳过元素\n\n\nlimit\n中间\nStream&lt;T&gt;\n\n\n截短\n\n\nmap\n中间\nStream&lt;R&gt;\nFunction&lt;T, R&gt;\nT -&gt; R\n映射\n\n\nflatMap\n中间\nStream&lt;R&gt;\nFunction&lt;T, Stream&lt;R&gt;&gt;\nT -&gt; Stream&lt;R&gt;\n展平\n\n\nsorted\n中间\nStream&lt;T&gt;\nComparator&lt;T&gt;\n(T, T) -&gt; int\n排序\n\n\npeek\n中间\nStream&lt;T&gt;\nConsumer&lt;T&gt;\nT -&gt; void\n消费流中的每个元素，主要用于调试\n\n\nanyMatch\n终端\nboolean\nPredicate&lt;T&gt;\nT -&gt; boolean\n是否至少匹配一个元素\n\n\nnoneMatch\n终端\nboolean\nPredicate&lt;T&gt;\nT -&gt; boolean\n是否匹配所有元素\n\n\nallMatch\n终端\nboolean\nPredicate&lt;T&gt;\nT -&gt; boolean\n是否没有任何元素匹配\n\n\nfindAny\n终端\nOptional&lt;T&gt;\n\n\n查找所有元素\n\n\nfindFirst\n终端\nOptional&lt;T&gt;\n\n\n查找第一个元素\n\n\nforeach\n终端\nvoid\nConsumer&lt;T&gt;\nT -&gt; void\n消费流中的每个元素并对其应用Lambda。这一操作返回void\n\n\ncollect\n终端\nR\nT -&gt; void\n\n把流归约成一个集合，比如List、Map 甚至是Integer\n\n\nreduce\n终端\nOptional&lt;T&gt;\nBinaryOperator&lt;T&gt;\n(T, T) -&gt; T\n归约\n\n\ncount\n终端\nlong\n\n\n查找第一个元素\n\n\n\n实际场景\n筛选和切片\n\nfilter: 根据传入的Predicate函数式接口, 返回一个包括所有符合条件元素的流\ndistinct: 返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流\nskip: 返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流\nlimit: 该方法会返回一个不超过给定长度的流。如果流是有序的,则最多返回前n个元素\n\nList&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 1, 3, 3, 2, 4, 6, 8); \nnumbers.stream() \n .filter(i -&gt; i % 2 &#x3D;&#x3D; 0) &#x2F;&#x2F; 过滤出偶数\n .distinct()              &#x2F;&#x2F; 相同的数字删除\n .skip(1)                 &#x2F;&#x2F; 跳过第一个元素\n .limit(2)                &#x2F;&#x2F; 取出前两个数\n .forEach(System.out::println); &#x2F;&#x2F; 4, 6  \n映射和展平\n\nmap: 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素\nflatMap: 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素\n\nList&lt;String&gt; words &#x3D; Arrays.asList(&quot;Hello&quot;,&quot;World&quot;);\nList&lt;String&gt; uniqueCharacters &#x3D; words.stream()\n        .map(w -&gt; w.split(&quot;&quot;))    &#x2F;&#x2F; 映射成一组字符数组\n        .flatMap(Arrays::stream)  &#x2F;&#x2F; 数组展平成一个数组\n        .distinct()               &#x2F;&#x2F; 字符去重\n        .collect(Collectors.toList());\n\n查找和匹配\n\nanyMatch: 流中是否有一个元素能匹配给定的条件\nnonneMatch: 流中是否没有一个元素能匹配给定的条件\nfindAny: 方法将返回当前流中的任意元素\nfindFirst: 方法将返回当前流中的第一个元素\n\n&#x2F;&#x2F; anyMatch\nif(menu.stream().anyMatch(Dish::isVegetarian))&#123; \n    System.out.println(&quot;The menu is (somewhat) vegetarian friendly!!&quot;); \n&#125;\n\n&#x2F;&#x2F; nonneMatch\nboolean isHealthy &#x3D; menu.stream() \n    .noneMatch(d -&gt; d.getCalories() &gt;&#x3D; 1000);\n\n&#x2F;&#x2F; findAny \nOptional&lt;Dish&gt; dish &#x3D; menu.stream() \n    .filter(Dish::isVegetarian) \n    .findAny(); \n\n&#x2F;&#x2F; findFirst\nList&lt;Integer&gt; someNumbers &#x3D; Arrays.asList(1, 2, 3, 4, 5); \nOptional&lt;Integer&gt; firstSquareDivisibleByThree &#x3D; someNumbers.stream() \n    .map(x -&gt; x * x) \n    .filter(x -&gt; x % 3 &#x3D;&#x3D; 0) \n    .findFirst(); &#x2F;&#x2F; 9 \n归约和汇总\n\nreduce: reduce 操作可以实现从一组值中生成一个值\nmax: 获取最大值\nmin: 获取最小值\ncount: 获取总数\nCollectors.joining: 字符串合并\n\nList&lt;Integer&gt; nums &#x3D; Arrays.asList(1,4,5,6,78);\n\n&#x2F;&#x2F; max\nInteger max &#x3D; nums.stream().max(Integer::compare).get(); &#x2F;&#x2F; 78\n\n&#x2F;&#x2F; min\nInteger min &#x3D; nums.stream().min(Integer::compare).get(); &#x2F;&#x2F; 1\n\n&#x2F;&#x2F; count\nLong count &#x3D; nums.stream().count(); &#x2F;&#x2F; 5\n\n&#x2F;&#x2F; reduce 求和\nInteger sum &#x3D; nums.stream().reduce(Integer::sum).get(); &#x2F;&#x2F; 94\n\nList&lt;String&gt; names &#x3D; Arrays.asList(&quot;Zebe&quot;, &quot;Hebe&quot;, &quot;Mary&quot;, &quot;July&quot;, &quot;David&quot;);\n\n&#x2F;&#x2F; 字符串合并\n&#x2F;&#x2F; 拼接成 [x, y, z] 形式\nString result1 &#x3D; names.stream().collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));\n&#x2F;&#x2F; 拼接成 x, y, z 形式\nString result2 &#x3D; names.stream().collect(Collectors.joining(&quot;,&quot;));\n&#x2F;&#x2F; 拼接成 xyz 形式\nString result3 &#x3D; names.stream().collect(Collectors.joining());\n分组和分区\n\nCollectors.groupingBy: 对数据按一定规则分组\nCollectors.partitioningBy: 分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函\n数\n\nList&lt;Student&gt; stuList &#x3D; new ArrayList&lt;Student&gt;();\nStudent stu1 &#x3D; new Student(&quot;10001&quot;, &quot;孙权&quot;, &quot;1000101&quot;, 16, &#39;男&#39;);\nStudent stu2 &#x3D; new Student(&quot;10001&quot;, &quot;曹操&quot;, &quot;1000102&quot;, 16, &#39;男&#39;);\nStudent stu3 &#x3D; new Student(&quot;10002&quot;, &quot;刘备&quot;, &quot;1000201&quot;, 16, &#39;男&#39;);\nStudent stu4 &#x3D; new Student(&quot;10002&quot;, &quot;大乔&quot;, &quot;1000202&quot;, 16, &#39;女&#39;);\nStudent stu5 &#x3D; new Student(&quot;10002&quot;, &quot;小乔&quot;, &quot;1000203&quot;, 16, &#39;女&#39;);\nStudent stu6 &#x3D; new Student(&quot;10003&quot;, &quot;诸葛亮&quot;, &quot;1000301&quot;, 16, &#39;男&#39;);\n\n&#x2F;&#x2F; 按班级分组\nMap&lt;String, List&lt;Student&gt;&gt; collect &#x3D; stuList.stream()\n    .collect(Collectors.groupingBy(Student::getClassId)); &#x2F;&#x2F; &#123;&quot;10001&quot;:[], ...&#125;\n&#x2F;&#x2F; 或者使用Collectors.toMap按班级分组\nMap&lt;String, List&lt;Student&gt;&gt; collect1 &#x3D; stuList.stream()\n        .collect(Collectors.toMap(Student::getClassId,\n                stu -&gt; new ArrayList&lt;Student&gt;()&#123;&#123;add(stu);&#125;&#125;,\n                (a,b) -&gt; &#123;a.addAll(b);return a;&#125;));       &#x2F;&#x2F; &#123;&quot;10001&quot;:[], ...&#125;\n&#x2F;&#x2F; 按性别分组\nMap&lt;Boolean, List&lt;Student&gt;&gt; collect2 &#x3D; stuList.stream()\n    .collect(Collectors.partitioningBy(stu -&gt; \n    Objects.equals(&#39;男stu.getSex())));                    &#x2F;&#x2F; &#123;&quot;false&quot;:[], &quot;true&quot;: []&#125;\n\n收集器\n收集器非常有用，因为用它可以简洁而灵活地定义collect用来生成结果集合的标准。更具体地说，对流调用\ncollect方法将对流中的元素触发一个归约操作（由Collector来参数化）。例如上述的Collectors.groupingBy、Collectors.partitioningBy\n常用Collectors类的静态工厂方法\n\n\n\n工厂方法\n返回类型\n用于\n\n\n\n\ntoList\nList&lt;T&gt;\n把流中所有项目收集到一个 List\n\n\n使用示例: List&lt;Dish&gt; dishes = menuStream.collect(toList());\n\n\n\n\ntoSet\nSet&lt;T&gt;\n把流中所有项目收集到一个 Set，删除重复项\n\n\n使用示例: ：Set&lt;Dish&gt; dishes = menuStream.collect(toSet());\n\n\n\n\ntoCollection\nCollection&lt;T&gt;\n把流中所有项目收集到给定的供应源创建的集合\n\n\n使用示例: java Collection&lt;Dish&gt; dishes = menuStream.collect(toCollection(), ArrayList::new);\n\n\n\n\ncounting\nLong\n计算流中元素的个数\n\n\n使用示例: long howManyDishes = menuStream.collect(counting());\n\n\n\n\nsummingInt\nInteger\n对流中项目的一个整数属性求和\n\n\n使用示例: int totalCalories = menuStream.collect(summingInt(Dish::getCalories));\n\n\n\n\naveragingInt\nDouble\n计算流中项目 Integer 属性的平均值\n\n\n使用示例: double avgCalories = menuStream.collect(averagingInt(Dish::getCalories));\n\n\n\n\nsummarizingInt\nIntSummaryStatistics\n收集关于流中项目 Integer 属性的统计值，例如最大、最小、总和与平均值\n\n\n使用示例: IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories));\n\n\n\n\njoining\nString\n连接对流中每个项目调用 toString 方法所生成的字符串\n\n\n使用示例: String shortMenu = menuStream.map(Dish::getName).collect(joining(&quot;, &quot;));\n\n\n\n\nmaxBy\nOptional&lt;T&gt;\n一个包裹了流中按照给定比较器选出的最大元素的 Optional，或如果流为空则为 Optional.empty()\n\n\n使用示例: Optional&lt;Dish&gt; fattest = menuStream.collect(maxBy(comparingInt(Dish::getCalories)));\n\n\n\n\nminBy\nOptional&lt;T&gt;\n一个包裹了流中按照给定比较器选出的最小元素的 Optional，或如果流为空则为 Optional.empty()\n\n\n使用示例: Optional&lt;Dish&gt; lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories)));\n\n\n\n\nreducing\n归约操作产生的类型\n从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值\n\n\n使用示例: int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));\n\n\n\n\ncollectingAndThen\n转换函数返回的类型\n包裹另一个收集器，对其结果应用转换函数\n\n\n使用示例: int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size));\n\n\n\n\ngroupingBy\nMap&lt;K, List&lt;T&gt;&gt;\n根据项目的一个属性的值对流中的项目作问组，并将属性值作为结果 Map 的键\n\n\n使用示例: Map&lt;Dish.Type,List&lt;Dish&gt;&gt; dishesByType = menuStream.collect(groupingBy(Dish::getType));\n\n\n\n\npartitioningBy\nMap&lt;Boolean,List&lt;T&gt;&gt;\n根据对流中每个项目应用谓词的结果来对项目进行分区\n\n\n使用示例: Map&lt;Boolean,List&lt;Dish&gt;&gt; vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarian))\n\n\n\n\n\n","slug":"Java Stream 流式编程","date":"2022-06-06T07:30:06.000Z","categories_index":"java,Stream,流式编程","tags_index":"java,Stream","author_index":"如峰"},{"id":"2b987db277ec8f53b5baaa150ea429a6","title":"Java函数式编程","content":"引言\n什么是函数式编程，即可以把方法当做参数或者返回值传递或引用。在JavaScript中函数式编程已经很常见，但是Java Function是不能作为参数引用，为此Java 8中提出了三个概念\n\n\n\n\n\n\n\n\n\n\nLambda 表达式，也可以称为闭包，但我更愿意称为定义函数的简写表达式\n方法引用，可以直接引用已有Java类或对象（实例）的方法或构造器\n函数式接口，一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口\n\nLambda 表达式\njava8之前函数的引用方式\nArrays.sort(array, new Comparator&lt;String&gt;() &#123;\n    public int compare(String s1, String s2) &#123;\n        return s1.compareTo(s2);\n    &#125;\n&#125;);\n上述写法非常繁琐，从java8开始，我们可以使用Lambda表达式写。可以看出Lambda表达式是函数定义的简写方式，不用声明匿名类，JVM会自己帮我们做。\nArrays.sort(array, (String s1, String s2) -&gt; &#123;\n    return s1.compareTo(s2);\n&#125;);\nLambda表达式的基本语法\n(parameters) -&gt;&#123; statements; &#125;\nLambda的两个省略\n\n\n\n\n\n\n\n\n\n\n当箭头左边只有一个参数时,可省略()\na =&gt; &#123;return a + 1;&#125;\n当箭头右边只有一句话时,可省略&#123;&#125;与return\n(a, b) =&gt; a + b;\n\n变量作用域\n\nLambda表达式只能引用标记了final的外层局部变量，这就是说不能在Lambda内部修改定义在域外的局部变量，否则会编译错误\nLambda表达式的局部变量可以不用声明为final，但是必须不可被后面的代码修改(即隐性的具有final的语义)\n在Lambda表达式当中不允许声明一个与局部变量同名的参数或者局部变量。\n\n例如：\nString first &#x3D; &quot;&quot;;  \nComparator &lt; String &gt; comparator &#x3D; (first, second) -&gt; \n\tInteger.compare(first.length(), second.length()); &#x2F;&#x2F; 编译会出错\nint num &#x3D; 1;  \nConverter&lt;Integer, String&gt; s &#x3D; (param) -&gt; System.out.println(String.valueOf(param + num));\ns.convert(2);\nnum &#x3D; 5;  \n&#x2F;&#x2F; 报错信息：Local variable num defined in an enclosing scope must be final or effectively final\n方法引用\n方法引用通过方法的名字来指向一个方法，可以使语音的构造更加紧凑，减少冗余代码，方法引用使用一对冒号。\n对于Arrays.sort方法,第二个参数Comparator是一个单方法接口，除了可以传入Lambda表达式，我们还可以直接传入符合要求的方法引Arrays.sort(array, String::compareTo);\n方法引用的基本语法\n构造器的引用\n语法： Class::new\nfinal Car car &#x3D; Car.create( Car::new );\nfinal List&lt; Car &gt; cars &#x3D; Arrays.asList( car );\n静态方法的引用\n语法： Class::static_method\ncars.forEach( Car::collide );\n特定类的任意对象的方法引用\n语法： Class::method\ncars.forEach( Car::repair );\n特定对象的方法引用\n语法： instance::method\nfinal Car police &#x3D; Car.create( Car::new );\ncars.forEach( police::follow );\n函数式接口\nLambda表达式、方法引用只是针对方法的简写与特殊方法引用的简写。那我们该如何将更加复杂的函数传递和引用呢？\n那如何先声明一个可被传递或者引用的函数呢？使用@FunctionalInterface注解创建一个函数式接口即可\n@FunctionalInterface\ninterface Functional &#123;\n  String goodbye(String message);\n&#125;\n函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。\n函数式接口可以被隐式转换为 lambda 表达式。所以上面接口的实现方式可用Lambda表达式简写为\nFunctional fx &#x3D; message -&gt; System.out.println(&quot;Hello &quot; + message);\nfx.goodbye(&quot;world!!!&quot;);\n$$ \\underbrace{message -&gt; System.out.println(&quot;Hello &quot; + message)}_{函数} \\quad  \\underrightarrow{赋值} \\quad fx.goodbye $$\n并通过fx.goodbye(&quot;world!!!&quot;)调用。这也就是必须有且仅有一个抽象方法否则并不知道赋值给哪一个方法。\n四大函数式接口\n我们在使用函数式接口时，并不需要总是创建一个函数式接口。因为JAVA8已经为我们提供了常用的函数式接口。\n\n\n\n函数式接口名\n方法名\n作用\n特征\n示例\n\n\n\n\nSupplier\nget()  getAs类型()\n生产者函数式接口\n无参数  有返回值\nSupplier  BooleanSupplier  IntSupplier  LongSupplier  DoubleSupplier\n\n\nConsumer\naccept()\n消费者函数式接口\n单个参数  无返回值\nConsumer  IntConsumer  LongConsumer  DoubleConsumer\n\n\nPredicate\ntest()\n断言函数式接口\n2 参数  返回布尔型\nPredicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate\n\n\nFunction\napply()  applyAs类型()\n功能函数式接口\n单个参数  有返回值\nFunction  IntFunction  LongFunction  DoubleFunction  ToIntFunction  ToLongFunction  ToDoubleFunction  IntToLongFunction  IntToDoubleFunction  LongToIntFunction  LongToDoubleFunction  DoubleToIntFunction  DoubleToLongFunction\n\n\n\nsupplier&lt;T&gt;\n生产者函数式接口,无参数，返回一个T类型结果。如果返回类型是基本类型可以使用BooleanSupplier、IntSupplier、LongSupplier、DoubleSupplier\n示例\nSupplier&lt;String&gt; supplier &#x3D; String::new; \nSupplier&lt;Emp&gt; supplierEmp &#x3D; Emp::new;\nEmp emp &#x3D; supplierEmp.get();\nemp.setName(&quot;dd&quot;);\n\nSystem.out.println(supplier.get()); &#x2F;&#x2F; &quot;&quot;\nSystem.out.println(emp.getName());  &#x2F;&#x2F; dd\nConsumer&lt;T&gt;\n接受一个T类型输入参数并且无返回。如果T是基本类型可以使用IntConsumer、LongConsumer、DoubleConsumer,如果需要输入两个参数使用BiConsumer,如果有一个类型是Obj,一个类型是基本类型可以使用ObjIntConsumer、ObjLongConsumer、ObjDoubleConsumer\n示例\nEmp emp &#x3D; new Emp();\nConsumer&lt;Emp&gt; nameConsumer &#x3D; emp -&gt; System.out.println(emp.getName());  \nnameConsumer.accept(emp); &#x2F;&#x2F; 打印学生名字\nPredicate&lt;T&gt;\n接受一个T类型输入参数并且返回布尔值。如果T是基本类型可以使用IntPredicate、LongPredicate、DoublePredicate,如果需要输入两个参数使用BiPredicate。\n示例\nPredicate&lt;Integer&gt; predicate &#x3D; t -&gt; t &gt; 5;\nSystem.out.println(predicate.test(6)); &#x2F;&#x2F; true \nFunction&lt;T,R&gt;\n接受一个T类型输入参数返回一个R类型参数。如果T是基本类型可以使用\nIntFunction、LongFunction、DoubleFunction,如果R是基本类型ToIntFunction、ToLongFunction、ToDoubleFunction,如果T和R都是基本类型可以使用IntToLongFunction、IntToDoubleFunction、LongToIntFunction、LongToDoubleFunction、DoubleToIntFunction、DoubleToLongFunction,\n如果需要传入两个参数可以使用BiFunction,要是BiFunction返回类型是基本类型可以使用ToIntBiFunction、ToLongBiFunction、ToDoubleBiFunction。\n示例\nFunction&lt;Integer,Integer&gt; fuc &#x3D; t -&gt; t - 1;\nSystem.out.println(fuc.apply(6)); &#x2F;&#x2F; 5 \n其它函数式接口\n\n\n\n函数式接口名\n作用\n\n\n\n\nRunnable\n不返回结果的线程\n\n\nCallable\n返回结果的线程\n\n\nUnaryOperator\n表示对同一类型的两个操作数的操作，产生与操作数相同类型的结果。\n\n\nBinaryOperator\n表示对单个操作数产生与其操作数相同类型的结果的操作。\n\n\nComparator\n对同类型的两个参数作比较\n\n\n\n函数组合\n函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。\n\n\n\n组合方法\n作用\n支持接口\n\n\n\n\nandThen(argument)\n执行原操作,再执行参数操作\nFunction  BiFunction  Consumer  BiConsumer  IntConsumer  LongConsumer  DoubleConsumer  UnaryOperator  IntUnaryOperator  LongUnaryOperator  DoubleUnaryOperator  BinaryOperator\n\n\ncompose(argument)\n执行参数操作,再执行原操作\nFunction  UnaryOperator  IntUnaryOperator  LongUnaryOperator  DoubleUnaryOperator\n\n\nand(argument)\n原Predicate函数式接口和参数Predicate函数式接口的短路逻辑与\nPredicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate\n\n\nor(argument)\n原Predicate函数式接口和参数Predicate函数式接口的短路逻辑或\nPredicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate\n\n\nnegate()\n该Predicate函数式接口的逻辑非\nPredicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate\n\n\n\n下例使用了Function里的compose()和andThen()。代码示例：\n&#x2F;&#x2F; functional&#x2F;FunctionComposition.java\nimport java.util.function.*;\npublic class FunctionComposition &#123;\n  static Function&lt;String, String&gt;\n    f1 &#x3D; s -&gt; &#123;\n      System.out.println(s);\n      return s.replace(&#39;A&#39;, &#39;_&#39;);\n    &#125;,\n    f2 &#x3D; s -&gt; s.substring(3),\n    f3 &#x3D; s -&gt; s.toLowerCase(),\n    f4 &#x3D; f1.compose(f2).andThen(f3);\n  public static void main(String[] args) &#123;\n    System.out.println(\n      f4.apply(&quot;GO AFTER ALL AMBULANCES&quot;));\n  &#125;\n&#125;\n输出结果：\nAFTER ALL AMBULANCES\n_fter _ll _mbul_nces\n这里我们重点看正在创建的新函数f4。它调用apply()的方式与Function函数式接口几乎无异。f4组合后的新函数,compose(f2)表示f2的调用发生在f1之前,所以当f1获得字符串时，它已经被f2剥离了前三个字符。\n下例是Predicate的逻辑运算演示。代码示例：\n&#x2F;&#x2F; functional&#x2F;PredicateComposition.java\nimport java.util.function.*;\nimport java.util.stream.*;\npublic class PredicateComposition &#123;\n  static Predicate&lt;String&gt;\n    p1 &#x3D; s -&gt; s.contains(&quot;bar&quot;),\n    p2 &#x3D; s -&gt; s.length() &lt; 5,\n    p3 &#x3D; s -&gt; s.contains(&quot;foo&quot;),\n    p4 &#x3D; p1.negate().and(p2).or(p3);\n  public static void main(String[] args) &#123;\n    Stream.of(&quot;bar&quot;, &quot;foobar&quot;, &quot;foobaz&quot;, &quot;fongopuckey&quot;)\n      .filter(p4)\n      .forEach(System.out::println);\n  &#125;\n&#125;\n输出结果：\nfoobar\nfoobaz\np4是由p1、p2、p3组成,其判断逻辑是：如果字符串中不包含bar且长度小于5，或者它包含foo，则结果为true。\n正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了Java Stream。首先，我创建了一个字符串对象的流，然后将每个对象传递给filter()操作。filter()使用p4的谓词来过滤。最后我们使用forEach()将println方法引用应用在每个留存的对象上。\n柯里化和部分求值\n将一个多参数的函数，转换为一系列单参数函数。\n&#x2F;&#x2F; functional&#x2F;CurryingAndPartials.java\nimport java.util.function.*;\npublic class CurryingAndPartials &#123;\n   &#x2F;&#x2F; 未柯里化:\n   static String uncurried(String a, String b) &#123;\n      return a + b;\n   &#125;\n   public static void main(String[] args) &#123;\n      &#x2F;&#x2F; 柯里化的函数:\n      Function&lt;String, Function&lt;String, String&gt;&gt; sum &#x3D;\n         a -&gt; b -&gt; a + b; &#x2F;&#x2F; [1]\n      System.out.println(uncurried(&quot;Hi &quot;, &quot;Ho&quot;));\n      Function&lt;String, String&gt;\n        hi &#x3D; sum.apply(&quot;Hi &quot;); &#x2F;&#x2F; [2]\n      System.out.println(hi.apply(&quot;Ho&quot;));\n      &#x2F;&#x2F; 部分应用:\n      Function&lt;String, String&gt; sumHi &#x3D;\n        sum.apply(&quot;Hup &quot;);\n      System.out.println(sumHi.apply(&quot;Ho&quot;));\n      System.out.println(sumHi.apply(&quot;Hey&quot;));\n   &#125;\n&#125;\n输出结果：\nHi Ho\nHi Ho\nHup Ho\nHup Hey\n\n\n\n\n\n\n\n\n\n这一连串的箭头很巧妙。注意，在函数接口声明中，第二个参数是另一个函数。\n柯里化的目的是能够通过提供单个参数来创建一个新函数，所以现在有了一个&quot;带参函数&quot;和剩下的&quot;自由函数&quot;(free argument)。实际上，你从一个双参数函数开始，最后得到一个单参数函数。\n我们可以通过继续添加层级来柯里化一个三参数函数:\n&#x2F;&#x2F; functional&#x2F;Curry3Args.java\nimport java.util.function.*;\npublic class Curry3Args &#123;\n   public static void main(String[] args) &#123;\n      Function&lt;String,\n        Function&lt;String,\n          Function&lt;String, String&gt;&gt;&gt; sum &#x3D;\n            a -&gt; b -&gt; c -&gt; a + b + c;\n      Function&lt;String,\n        Function&lt;String, String&gt;&gt; hi &#x3D;\n          sum.apply(&quot;Hi &quot;);\n      Function&lt;String, String&gt; ho &#x3D;\n        hi.apply(&quot;Ho &quot;);\n      System.out.println(ho.apply(&quot;Hup&quot;));\n   &#125;\n&#125;\n输出结果：\nHi Ho Hup\n对于每一级的箭头级联(Arrow-cascading),你都会在类型声明周围包裹另一个Function。\n处理基本类型和装箱时,请使用适当的函数式接口：\n&#x2F;&#x2F; functional&#x2F;CurriedIntAdd.java\nimport java.util.function.*;\npublic class CurriedIntAdd &#123;\n  public static void main(String[] args) &#123;\n    IntFunction&lt;IntUnaryOperator&gt;\n      curriedIntAdd &#x3D; a -&gt; b -&gt; a + b;\n    IntUnaryOperator add4 &#x3D; curriedIntAdd.apply(4);\n    System.out.println(add4.applyAsInt(5));\n      &#125;\n&#125;\n输出结果：\n9\n总结\n在绝大多数多数的程序编写中,Lambda表达式和方法引用并配合Java Stream编程的方式的应用较多，但是函数式接口和柯里化的应用较少。个人觉得一方便绝大多数的开发还是CRUD和数据的梳理，另一方面只有在涉及到架构时或者编写通用工具方法时才有可能使用到函数式接口和柯里化。开发者在使用函数式接口和柯里化时需要从面向对象的思考方式做出部分的转变，以适应函数式编程。而且Java已经有了这么多年的历史，即使不使用函数式接口和柯里化也有成熟的解决方式，而市面上也并未有统一、成熟、全面的关于函数式接口和柯里化在Java开发中的规范要求去替代过去的方式。\n","slug":"Java函数式编程","date":"2022-05-31T13:30:06.000Z","categories_index":"java,函数式编程","tags_index":"java,函数式编程","author_index":"如峰"},{"id":"6a8b4d4d5ad2121dc1df69e7c613a802","title":"Lombok的使用一进阶篇","content":"进阶注解解析\n@SuperBuilder(实验性功能)\n是一个帮助类生成复杂的构建器 API。将循允许我们使用以下的方式去实例化对象，但是对继承的类的属性不会忽略,但是超类也必须使用此注解。\n使用方式可参照@Builder\n@Jacksonized(实验性功能)\n此注解是@Builder和@SuperBuilder的附加注解,允许他们Jackson序列化/反序列化不被报错\n例如\n@Jacksonized @Builder\n@JsonIgnoreProperties(ignoreUnknown &#x3D; true)\npublic class JacksonExample &#123;\n\tprivate List&lt;Foo&gt; foos;\n&#125;\n@Accessors(实验性功能)\n使用此注解允许使用以下的链式方式调用方法,注解的fluent熟悉默认为false,设置为true时,则getter/setter方法，没有get/set前缀。\nUser user &#x3D; new User().age(31).name(&quot;pollyduan&quot;);\n例如\nimport lombok.experimental.Accessors;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Accessors(fluent &#x3D; true)\npublic class AccessorsExample &#123;\n  @Getter @Setter\n  private int age &#x3D; 10;\n&#125;\n\nclass PrefixExample &#123;\n  @Accessors(prefix &#x3D; &quot;f&quot;) @Getter\n  private String fName &#x3D; &quot;Hello, World!&quot;;\n&#125;\n编译后的实体\npublic class AccessorsExample &#123;\n  private int age &#x3D; 10;\n  \n  public int age() &#123;\n    return this.age;\n  &#125;\n  \n  public AccessorsExample age(final int age) &#123;\n    this.age &#x3D; age;\n    return this;\n  &#125;\n&#125;\n\nclass PrefixExample &#123;\n  private String fName &#x3D; &quot;Hello, World!&quot;;\n  \n  public String getName() &#123;\n    return this.fName;\n  &#125;\n&#125;\nvar关键字\nvar替换掉了原来的val。var关键字可以让我们在定义一个变量时候不需要提前指定它的类型，它的实际的类型将由初始化的表达式推断,var声明的变量是非final的,而val声明的变量是final的。若要使用var声明final\n例如\nvar example &#x3D; new ArrayList&lt;String&gt;();\nexample.add(&quot;welcome to hangge.com&quot;);","slug":"Lombok的使用—进阶篇","date":"2022-05-25T15:30:06.000Z","categories_index":"Lombok","tags_index":"Lombok","author_index":"如峰"},{"id":"f4f9a107b18653850d81e048925a42ea","title":"Lombok的使用一中级篇","content":"高级注解解析\n@Builder\n是一个帮助类生成复杂的构建器 API。将允许我们使用以下的方式去实例化对象，但是对继承的类的属性会忽略。\nPerson.builder()\n   .name(&quot;Adam Savage&quot;)\n   .city(&quot;San Francisco&quot;)\n   .job(&quot;Mythbusters&quot;)\n   .job(&quot;Unchained Reaction&quot;)\n  .build();\n当你想为某一字段使用默认值时，使用@Builder.Default\n@Builder.Default \nprivate long created &#x3D; System.currentTimeMillis()\n当某个字段为集合类型时，使用@Singular\n@Singular \nprivate Set&lt;String&gt; occupations;\n例如\n\nimport lombok.Builder;\nimport lombok.Singular;\nimport java.util.Set;\n\n@Builder\npublic class BuilderExample &#123;\n  @Builder.Default private long created &#x3D; System.currentTimeMillis();\n  private String name;\n  private int age;\n  @Singular private Set&lt;String&gt; occupations;\n&#125;\n编译后的实体类\nimport java.util.Set;\n\npublic class BuilderExample &#123;\n  private long created;\n  private String name;\n  private int age;\n  private Set&lt;String&gt; occupations;\n  \n  BuilderExample(String name, int age, Set&lt;String&gt; occupations) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.occupations &#x3D; occupations;\n  &#125;\n  \n  private static long $default$created() &#123;\n    return System.currentTimeMillis();\n  &#125;\n  \n  public static BuilderExampleBuilder builder() &#123;\n    return new BuilderExampleBuilder();\n  &#125;\n  \n  public static class BuilderExampleBuilder &#123;\n    private long created;\n    private boolean created$set;\n    private String name;\n    private int age;\n    private java.util.ArrayList&lt;String&gt; occupations;\n    \n    BuilderExampleBuilder() &#123;\n    &#125;\n    \n    public BuilderExampleBuilder created(long created) &#123;\n      this.created &#x3D; created;\n      this.created$set &#x3D; true;\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder name(String name) &#123;\n      this.name &#x3D; name;\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder age(int age) &#123;\n      this.age &#x3D; age;\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder occupation(String occupation) &#123;\n      if (this.occupations &#x3D;&#x3D; null) &#123;\n        this.occupations &#x3D; new java.util.ArrayList&lt;String&gt;();\n      &#125;\n      \n      this.occupations.add(occupation);\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder occupations(Collection&lt;? extends String&gt; occupations) &#123;\n      if (this.occupations &#x3D;&#x3D; null) &#123;\n        this.occupations &#x3D; new java.util.ArrayList&lt;String&gt;();\n      &#125;\n\n      this.occupations.addAll(occupations);\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder clearOccupations() &#123;\n      if (this.occupations !&#x3D; null) &#123;\n        this.occupations.clear();\n      &#125;\n      \n      return this;\n    &#125;\n\n    public BuilderExample build() &#123;\n      &#x2F;&#x2F; complicated switch statement to produce a compact properly sized immutable set omitted.\n      Set&lt;String&gt; occupations &#x3D; ...;\n      return new BuilderExample(created$set ? created : BuilderExample.$default$created(), name, age, occupations);\n    &#125;\n    \n    @java.lang.Override\n    public String toString() &#123;\n      return &quot;BuilderExample.BuilderExampleBuilder(created &#x3D; &quot; + this.created + &quot;, name &#x3D; &quot; + this.name + &quot;, age &#x3D; &quot; + this.age + &quot;, occupations &#x3D; &quot; + this.occupations + &quot;)&quot;;\n    &#125;\n  &#125;\n&#125;\n@SneakyThrows(慎用)\n可以用来偷偷抛出检查异常，而无需在方法的throws子句中实际声明它。\n例如\nimport lombok.SneakyThrows;\n\npublic class SneakyThrowsExample implements Runnable &#123;\n  @SneakyThrows(UnsupportedEncodingException.class)\n  public String utf8ToString(byte[] bytes) &#123;\n    return new String(bytes, &quot;UTF-8&quot;);\n  &#125;\n  \n  @SneakyThrows\n  public void run() &#123;\n    throw new Throwable();\n  &#125;\n&#125;\n编译后的实体\nimport lombok.Lombok;\n\npublic class SneakyThrowsExample implements Runnable &#123;\n  public String utf8ToString(byte[] bytes) &#123;\n    try &#123;\n      return new String(bytes, &quot;UTF-8&quot;);\n    &#125; catch (UnsupportedEncodingException e) &#123;\n      throw Lombok.sneakyThrow(e);\n    &#125;\n  &#125;\n  \n  public void run() &#123;\n    try &#123;\n      throw new Throwable();\n    &#125; catch (Throwable t) &#123;\n      throw Lombok.sneakyThrow(t);\n    &#125;\n  &#125;\n&#125;\n\n@Synchronized(慎用)\n此注解是synchronized方法修饰符的一个更安全的变体。就像synchronized，注解只能用于静态和实例方法。它的操作类似于synchronized关键字，但它锁定不同的对象。\n例如\nimport lombok.Synchronized;\n\npublic class SynchronizedExample &#123;\n  private final Object readLock &#x3D; new Object();\n  \n  @Synchronized\n  public static void hello() &#123;\n    System.out.println(&quot;world&quot;);\n  &#125;\n  \n  @Synchronized\n  public int answerToLife() &#123;\n    return 42;\n  &#125;\n  \n  @Synchronized(&quot;readLock&quot;)\n  public void foo() &#123;\n    System.out.println(&quot;bar&quot;);\n  &#125;\n&#125;\n编译后的实体\npublic class SynchronizedExample &#123;\n  private static final Object $LOCK &#x3D; new Object[0];\n  private final Object $lock &#x3D; new Object[0];\n  private final Object readLock &#x3D; new Object();\n  \n  public static void hello() &#123;\n    synchronized($LOCK) &#123;\n      System.out.println(&quot;world&quot;);\n    &#125;\n  &#125;\n  \n  public int answerToLife() &#123;\n    synchronized($lock) &#123;\n      return 42;\n    &#125;\n  &#125;\n  \n  public void foo() &#123;\n    synchronized(readLock) &#123;\n      System.out.println(&quot;bar&quot;);\n    &#125;\n  &#125;\n&#125;\n@With\n当你需要克隆对象，修改一个值而保留其他值不变时，则使用此注解。\n例如\nimport lombok.AccessLevel;\nimport lombok.NonNull;\nimport lombok.With;\n\npublic class WithExample &#123;\n  @With(AccessLevel.PROTECTED) @NonNull private final String name;\n  @With private final int age;\n  \n  public WithExample(@NonNull String name, int age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n  &#125;\n&#125;\n编译后的实体类\nimport lombok.NonNull;\n\npublic class WithExample &#123;\n  private @NonNull final String name;\n  private final int age;\n\n  public WithExample(String name, int age) &#123;\n    if (name &#x3D;&#x3D; null) throw new NullPointerException();\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n  &#125;\n\n  protected WithExample withName(@NonNull String name) &#123;\n    if (name &#x3D;&#x3D; null) throw new java.lang.NullPointerException(&quot;name&quot;);\n    return this.name &#x3D;&#x3D; name ? this : new WithExample(name, age);\n  &#125;\n\n  public WithExample withAge(int age) &#123;\n    return this.age &#x3D;&#x3D; age ? this : new WithExample(name, age);\n  &#125;\n&#125;\n@Getter(lazy=true)\n标注字段为懒加载字段，懒加载字段在创建对象时不会进行初始化，而是在第一次访问的时候才会初始化，后面再次访问也不会重复初始化。\n例如\nimport lombok.Getter;\n\npublic class GetterLazyExample &#123;\n  @Getter(lazy&#x3D;true) private final double[] cached &#x3D; expensive();\n  \n  private double[] expensive() &#123;\n    double[] result &#x3D; new double[1000000];\n    for (int i &#x3D; 0; i &lt; result.length; i++) &#123;\n      result[i] &#x3D; Math.asin(i);\n    &#125;\n    return result;\n  &#125;\n&#125;\n编译后的实体\npublic class GetterLazyExample &#123;\n  private final java.util.concurrent.AtomicReference&lt;java.lang.Object&gt; cached &#x3D; new java.util.concurrent.AtomicReference&lt;java.lang.Object&gt;();\n  \n  public double[] getCached() &#123;\n    java.lang.Object value &#x3D; this.cached.get();\n    if (value &#x3D;&#x3D; null) &#123;\n      synchronized(this.cached) &#123;\n        value &#x3D; this.cached.get();\n        if (value &#x3D;&#x3D; null) &#123;\n          final double[] actualValue &#x3D; expensive();\n          value &#x3D; actualValue &#x3D;&#x3D; null ? this.cached : actualValue;\n          this.cached.set(value);\n        &#125;\n      &#125;\n    &#125;\n    return (double[])(value &#x3D;&#x3D; this.cached ? null : value);\n  &#125;\n  \n  private double[] expensive() &#123;\n    double[] result &#x3D; new double[1000000];\n    for (int i &#x3D; 0; i &lt; result.length; i++) &#123;\n      result[i] &#x3D; Math.asin(i);\n    &#125;\n    return result;\n  &#125;\n&#125;\n@Cleanup\n主要用来修饰 IO 流相关类, 会在 finally 代码块中对该资源进行 close();\n例如\nimport lombok.Cleanup;\nimport java.io.*;\n\npublic class CleanupExample &#123;\n  public static void main(String[] args) throws IOException &#123;\n    @Cleanup InputStream in &#x3D; new FileInputStream(args[0]);\n    @Cleanup OutputStream out &#x3D; new FileOutputStream(args[1]);\n    byte[] b &#x3D; new byte[10000];\n    while (true) &#123;\n      int r &#x3D; in.read(b);\n      if (r &#x3D;&#x3D; -1) break;\n      out.write(b, 0, r);\n    &#125;\n  &#125;\n&#125;\n编译后的实体\nimport java.io.*;\n\npublic class CleanupExample &#123;\n  public static void main(String[] args) throws IOException &#123;\n    InputStream in &#x3D; new FileInputStream(args[0]);\n    try &#123;\n      OutputStream out &#x3D; new FileOutputStream(args[1]);\n      try &#123;\n        byte[] b &#x3D; new byte[10000];\n        while (true) &#123;\n          int r &#x3D; in.read(b);\n          if (r &#x3D;&#x3D; -1) break;\n          out.write(b, 0, r);\n        &#125;\n      &#125; finally &#123;\n        if (out !&#x3D; null) &#123;\n          out.close();\n        &#125;\n      &#125;\n    &#125; finally &#123;\n      if (in !&#x3D; null) &#123;\n        in.close();\n      &#125;\n    &#125;\n  &#125;\n&#125;\n","slug":"Lombok的使用一中级篇","date":"2022-05-19T15:30:06.000Z","categories_index":"Lombok","tags_index":"Lombok","author_index":"如峰"},{"id":"ad1f662ab87a679b9b7a6abe69e2649c","title":"Lombok的使用一基础篇","content":"序言\nLombok是一款 Java 开发插件，使得 Java 开发者可以通过其定义的一些注解来消除业务工程中冗长和繁琐的代码\n常用注解解析\n@Data\n@Data是一个快捷注解，包含@Getter,@Setter,@ToString,@EqualsAndHashCode and @RequiredArgsConstructor注解。当@Data设置于类上时，将自动生成Getter、Setter、ToString、Equals、HashCode方法和默认构造器。\n例如\nimport lombok.Data;\n\n@Data\npublic class DataExample &#123;\n    private String name;\n&#125;\n编译后的实体类\npublic class DataExample &#123;\n    public String name;\n\n    public DataExample() &#123;\n    &#125;\n\n    public String getName() &#123;\n        return this.name;\n    &#125;\n\n    public void setName(final String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public boolean equals(final Object o) &#123;\n        if (o &#x3D;&#x3D; this) &#123;\n            return true;\n        &#125; else if (!(o instanceof DataExample)) &#123;\n            return false;\n        &#125; else &#123;\n            DataExample other &#x3D; (DataExample)o;\n            if (!other.canEqual(this)) &#123;\n                return false;\n            &#125; else &#123;\n                Object this$name &#x3D; this.getName();\n                Object other$name &#x3D; other.getName();\n                if (this$name &#x3D;&#x3D; null) &#123;\n                    if (other$name !&#x3D; null) &#123;\n                        return false;\n                    &#125;\n                &#125; else if (!this$name.equals(other$name)) &#123;\n                    return false;\n                &#125;\n\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    protected boolean canEqual(final Object other) &#123;\n        return other instanceof DataExample;\n    &#125;\n\n    public int hashCode() &#123;\n        int PRIME &#x3D; true;\n        int result &#x3D; 1;\n        Object $name &#x3D; this.getName();\n        int result &#x3D; result * 59 + ($name &#x3D;&#x3D; null ? 43 : $name.hashCode());\n        return result;\n    &#125;\n\n    public String toString() &#123;\n        return &quot;DataExample(name&#x3D;&quot; + this.getName() + &quot;)&quot;;\n    &#125;\n&#125;\n\n@Getter and @Setter\n当为某一字段设置@Getter、@Setter注解时将自动生成此字段的Getter、Setter方法。当为某实体类设置@Getter、@Setter注解时，相当于为类中所有非静态字段设置@Getter、@Setter注解。\n例如\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class GetterSetterExample &#123;\n    private int age ;\n&#125;\n编译后的实体类\npublic class GetterSetterExample &#123;\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n@NoArgsConstructor、@RequiredArgsConstructor、@AllArgsConstructor构造器注解\n@NoArgsConstructor 将生成一个没有参数的构造函数，如果有final字段需使用@NoArgsConstructor(force = true)初始化\n@AllArgsConstructor 为类中的每个字段生成一个带有 1 个参数的构造函数。标注@NonNull参数会进行空检查。\n@RequiredArgsConstructor 生成构造包含所有必须字段的参数，包括含@NotNull注解的字段并做空检查，和final修饰且未初始化的字段。\n例如\n\nimport lombok.AccessLevel;\nimport lombok.RequiredArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport lombok.NonNull;\n\n@RequiredArgsConstructor(staticName &#x3D; &quot;of&quot;)\n@AllArgsConstructor(access &#x3D; AccessLevel.PROTECTED)\npublic class ConstructorExample&lt;T&gt; &#123;\n  private int x, y;\n  @NonNull private T description;\n  \n  @NoArgsConstructor\n  public static class NoArgsExample &#123;\n    @NonNull private String field;\n  &#125;\n&#125;\n编译后的实体类\npublic class ConstructorExample&lt;T&gt; &#123;\n  private int x, y;\n  @NonNull private T description;\n  \n  private ConstructorExample(T description) &#123;\n    if (description &#x3D;&#x3D; null) throw new NullPointerException(&quot;description&quot;);\n    this.description &#x3D; description;\n  &#125;\n  \n  public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) &#123;\n    return new ConstructorExample&lt;T&gt;(description);\n  &#125;\n  \n  @java.beans.ConstructorProperties(&#123;&quot;x&quot;, &quot;y&quot;, &quot;description&quot;&#125;)\n  protected ConstructorExample(int x, int y, T description) &#123;\n    if (description &#x3D;&#x3D; null) throw new NullPointerException(&quot;description&quot;);\n    this.x &#x3D; x;\n    this.y &#x3D; y;\n    this.description &#x3D; description;\n  &#125;\n  \n  public static class NoArgsExample &#123;\n    @NonNull private String field;\n    \n    public NoArgsExample() &#123;\n    &#125;\n  &#125;\n&#125;\n@EqualsAndHashCode\n任何类定义都可以用注释@EqualsAndHashCode来让Lombok生成equals(Object other)和hashCode()方法的实现。\n例如\nimport lombok.EqualsAndHashCode;\n\n@EqualsAndHashCode\npublic class EqualsAndHashCodeExample &#123;\n  private transient int transientVar &#x3D; 10;\n  private String name;\n  private double score;\n  @EqualsAndHashCode.Exclude private Shape shape &#x3D; new Square(5, 10);\n  private String[] tags;\n  @EqualsAndHashCode.Exclude private int id;\n  \n  public String getName() &#123;\n    return this.name;\n  &#125;\n  \n  @EqualsAndHashCode(callSuper&#x3D;true)\n  public static class Square extends Shape &#123;\n    private final int width, height;\n    \n    public Square(int width, int height) &#123;\n      this.width &#x3D; width;\n      this.height &#x3D; height;\n    &#125;\n  &#125;\n&#125;\n编译后的实体类\nimport java.util.Arrays;\n\npublic class EqualsAndHashCodeExample &#123;\n  private transient int transientVar &#x3D; 10;\n  private String name;\n  private double score;\n  private Shape shape &#x3D; new Square(5, 10);\n  private String[] tags;\n  private int id;\n  \n  public String getName() &#123;\n    return this.name;\n  &#125;\n  \n  @Override public boolean equals(Object o) &#123;\n    if (o &#x3D;&#x3D; this) return true;\n    if (!(o instanceof EqualsAndHashCodeExample)) return false;\n    EqualsAndHashCodeExample other &#x3D; (EqualsAndHashCodeExample) o;\n    if (!other.canEqual((Object)this)) return false;\n    if (this.getName() &#x3D;&#x3D; null ? other.getName() !&#x3D; null : !this.getName().equals(other.getName())) return false;\n    if (Double.compare(this.score, other.score) !&#x3D; 0) return false;\n    if (!Arrays.deepEquals(this.tags, other.tags)) return false;\n    return true;\n  &#125;\n  \n  @Override public int hashCode() &#123;\n    final int PRIME &#x3D; 59;\n    int result &#x3D; 1;\n    final long temp1 &#x3D; Double.doubleToLongBits(this.score);\n    result &#x3D; (result*PRIME) + (this.name &#x3D;&#x3D; null ? 43 : this.name.hashCode());\n    result &#x3D; (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32));\n    result &#x3D; (result*PRIME) + Arrays.deepHashCode(this.tags);\n    return result;\n  &#125;\n  \n  protected boolean canEqual(Object other) &#123;\n    return other instanceof EqualsAndHashCodeExample;\n  &#125;\n  \n  public static class Square extends Shape &#123;\n    private final int width, height;\n    \n    public Square(int width, int height) &#123;\n      this.width &#x3D; width;\n      this.height &#x3D; height;\n    &#125;\n    \n    @Override public boolean equals(Object o) &#123;\n      if (o &#x3D;&#x3D; this) return true;\n      if (!(o instanceof Square)) return false;\n      Square other &#x3D; (Square) o;\n      if (!other.canEqual((Object)this)) return false;\n      if (!super.equals(o)) return false;\n      if (this.width !&#x3D; other.width) return false;\n      if (this.height !&#x3D; other.height) return false;\n      return true;\n    &#125;\n    \n    @Override public int hashCode() &#123;\n      final int PRIME &#x3D; 59;\n      int result &#x3D; 1;\n      result &#x3D; (result*PRIME) + super.hashCode();\n      result &#x3D; (result*PRIME) + this.width;\n      result &#x3D; (result*PRIME) + this.height;\n      return result;\n    &#125;\n    \n    protected boolean canEqual(Object other) &#123;\n      return other instanceof Square;\n    &#125;\n  &#125;\n&#125;\n@NonNull\n您可以@NonNull在字段、方法、构造函数的参数上使用。这将导致Lombok为您生成一个空检查语句。\n例如\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something &#123;\n  private String name;\n  \n  public NonNullExample(@NonNull Person person) &#123;\n    super(&quot;Hello&quot;);\n    this.name &#x3D; person.getName();\n  &#125;\n&#125;\n编译后的实体类\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something &#123;\n  private String name;\n  \n  public NonNullExample(@NonNull Person person) &#123;\n    super(&quot;Hello&quot;);\n    if (person &#x3D;&#x3D; null) &#123;\n      throw new NullPointerException(&quot;person is marked non-null but is null&quot;);\n    &#125;\n    this.name &#x3D; person.getName();\n  &#125;\n&#125;\n@Log\nLombok里关于@Log添加了多种变体，无论使用哪个，都将生成一个静态的final log字段，按照你使用的日志框架的通常规定的方式进行初始化，然后你可以使用它来编写日志语句。变体有@CommonsLog、@Flogger、@JBossLog、@Log、@Log4j、@Log4j2、@Slf4j、@XSlf4j、@CustomLog。\n例如\nimport lombok.extern.java.Log;\nimport lombok.extern.slf4j.Slf4j;\n\n@Log\npublic class LogExample &#123;\n  \n  public static void main(String... args) &#123;\n    log.severe(&quot;Something&#39;s wrong here&quot;);\n  &#125;\n&#125;\n\n@Slf4j\npublic class LogExampleOther &#123;\n  \n  public static void main(String... args) &#123;\n    log.error(&quot;Something else is wrong here&quot;);\n  &#125;\n&#125;\n\n@CommonsLog(topic&#x3D;&quot;CounterLog&quot;)\npublic class LogExampleCategory &#123;\n\n  public static void main(String... args) &#123;\n    log.error(&quot;Calling the &#39;CounterLog&#39; with a message&quot;);\n  &#125;\n&#125;\n编译后的实体类\npublic class LogExample &#123;\n  private static final java.util.logging.Logger log &#x3D; java.util.logging.Logger.getLogger(LogExample.class.getName());\n  \n  public static void main(String... args) &#123;\n    log.severe(&quot;Something&#39;s wrong here&quot;);\n  &#125;\n&#125;\n\npublic class LogExampleOther &#123;\n  private static final org.slf4j.Logger log &#x3D; org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);\n  \n  public static void main(String... args) &#123;\n    log.error(&quot;Something else is wrong here&quot;);\n  &#125;\n&#125;\n\npublic class LogExampleCategory &#123;\n  private static final org.apache.commons.logging.Log log &#x3D; org.apache.commons.logging.LogFactory.getLog(&quot;CounterLog&quot;);\n\n  public static void main(String... args) &#123;\n    log.error(&quot;Calling the &#39;CounterLog&#39; with a message&quot;);\n  &#125;\n&#125;\n","slug":"Lombok的使用一基础篇","date":"2022-05-19T15:30:06.000Z","categories_index":"Lombok","tags_index":"Lombok","author_index":"如峰"},{"id":"91e0f6f330b5dca608acfed732198bf6","title":"JavaScript代码技巧","content":"变量的声明\nvar、const、let的区别\n\n\n\n表头\nvar\nlet\nconst\n\n\n\n\n定义常量\n\n\n√\n\n\n定义变量\n√\n√\n\n\n\n可被释放\n√\n√\n√\n\n\n可被提升\n√\n\n\n\n\n重复定义检查\n\n√\n√\n\n\n可用于块级作用域\n\n√\n√\n\n\n\n多行变量声明的优化\nlet name &#x3D; 1;  &#x2F;&#x2F; 名称\nlet age &#x3D; 2;   &#x2F;&#x2F; 年龄\nlet classes &#x3D; 3; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\n\n&#x2F;&#x2F; 名称 年龄 班级\nlet [name, age, classes] &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 特别多的变量,当需要换行时的格式\nlet [name, age, classes]\n    &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 此方式默认值的设置,myClasses默认值设置3\nlet [name, age, myClasses]\n    &#x3D; [1, 2, class || 3];\n\n&#x2F;&#x2F; 声明三个都是undefined的变量\nlet [name, age, myClasses] &#x3D; [];\n&#x2F;&#x2F; 声明三个都是空的变量 \nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(4).join(&#39;0&#39;).split(&#39;&#39;);\n\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(3).fill(0);\nlet [name, age, myClasses] &#x3D; Array.from(&#123;length: 3&#125;).map(()&#x3D;&gt; 0)\n\n数组取值的优化\nlet arr &#x3D; [1, 2, 3];\nlet arr1 &#x3D; arr[0];\nlet arr2 &#x3D; arr[1];\nlet arr3 &#x3D; arr[2];\n\n&#x2F;&#x2F; 优化后\nlet arr &#x3D; [1, 2, 3];\nlet [arr1, arr2, arr3] &#x3D; arr;\n\n对象取值的优化\nlet student &#x3D; &#123;name:1, age:2, classes:3&#125;;\nlet name &#x3D; student.name;   &#x2F;&#x2F; 名称\nlet age &#x3D; student.age;     &#x2F;&#x2F; 年龄\nlet classes &#x3D; student.classes; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet &#123;name : name, age : age, classes : classes&#125; &#x3D; student;\n&#x2F;&#x2F; 变量与属性名不相同 (key : value) key:JSON对象的属性名 value:变量名\nlet &#123;name : myName, age : myAge, classes : myClasses&#125; &#x3D; student;\n&#x2F;&#x2F; 此种对象的默认值设置仅在等于undefined的时候触发Myclasses &#x3D; 0\nlet &#123;name : myName, age : myAge, classes : myClasses &#x3D; 0&#125; &#x3D; student;\n \nlet &#123;name , age , classes&#125; &#x3D; student;\n\n逻辑与 &amp;&amp; 、逻辑或 || 的使用\n在使用之前我们要理解逻辑与和逻辑或的重要特性,短路.\n逻辑与: 当前面为假时,则直接返回假,否则返回后面的结果\n逻辑或: 当前面为真时,则直接返回真,否则返回后面的结果\n默认值的优化\n&#x2F;&#x2F; myName默认值的优化\nlet name &#x3D; 1;\nif (name) &#123;\n    let myName &#x3D; name;\n&#125; else &#123;\n    let myName &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet name &#x3D; 1;\nlet myName &#x3D; name || 2;\n&#x2F;&#x2F; 扩展:我们在函数调用时设置默认值\ngetName(myName || name);\n\n单行if语句的优化\n&#x2F;&#x2F; 单行if语句的优化\nif(name)&#123; console.log(name)&#125;\n\n&#x2F;&#x2F; 优化后\nname &amp;&amp; console.log(name);\n\n取非空对象值的优化\n&#x2F;&#x2F; 取非空JSON值的优化\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\n\n&#x2F;&#x2F; student与student在代码逻辑中,只有一个有值,且我们要取出这个name,优先取student\nlet name &#x3D; null;\nif (student) &#123;\n    name &#x3D; student.name;\n&#125; else if(student1) &#123;\n    name &#x3D; student1.name;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\nlet name &#x3D; (student || student1)[&#39;name&#39;];\n&#x2F;&#x2F; 或者\nlet name &#x3D; (student || student1).name;\n\nJSON的使用\nJSON声明的优化\nlet student &#x3D; &#123;&#125;;\nlet classes &#x3D; 2;\nstudent.name &#x3D; 1;\nstudent.classes &#x3D; classes || 3;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; 2;\nlet student &#x3D; &#123;\n    name : 1,\n    classes : classes || 3,\n&#125;;\n\nJSON取值的优化\nlet student &#x3D; &#123;\n    name : 1,\n    classes1 : null,\n    classes2 : 3,\n&#125;;\n&#x2F;&#x2F; 当classes1为空时取classes2\nlet classes &#x3D; null;\nif (student.classes1) &#123;\n    classes &#x3D; student.classes1;\n&#125; else &#123;\n    classes &#x3D; student.classes2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; student.classes1 || student.classes2;\nlet classes &#x3D; student[&quot;classes1&quot;] || student[&#39;classes2&quot;];\n\n条件运算符的使用\nif else 语句的优化\nlet method &#x3D; request.method;\nif (method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n    let name &#x3D; request.getValue(&quot;name&quot;);\n&#125; else &#123;\n    let name &#x3D; request.getValue(&quot;custpage_name&quot;);\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet method &#x3D; request.method;\nlet name &#x3D; request.getValue(method &#x3D;&#x3D; &#39;GET&#39; ? &quot;name&quot; : &quot;custpage_name&quot;);\nlet name &#x3D; method &#x3D;&#x3D; &#39;GET&#39; ? request.getValue(&quot;name&quot;) : request.getValue(&quot;custpage_name&quot;);\n\n方法调用的优化\nlet isUp &#x3D; false;\nif (isUp)&#123;\n    up();\n&#125; else &#123;\n    down();\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet isUp &#x3D; false;\nisUp ? up() : down();\n&#x2F;&#x2F; 或者在函数的返回值使用条件运算符\nfunction jump(isUp)&#123;\n    return isUp ? up() : down();\n&#125;\n其它\n链式调用\nvar form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;);\nhtmlHeader.updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;);\nhtmlHeader.updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;);\nhtmlHeader.defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n\n&#x2F;&#x2F; 链式调用\nvar form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;).updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;).updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;).defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n字符串拼接\nlet n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\n\nlet string &#x3D; n + &quot;-&quot; + b + &quot;-&quot; + s + &quot;-&quot; + y;\nlet string2 &#x3D; n + b + s + y;\n\n&#x2F;&#x2F; 优化后\nlet n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\nlet string &#x3D; [n, b ,s,y].join(&quot;-&quot;);\nlet string2 &#x3D; n.concat(b, s, y);\n\n&#x2F;&#x2F; 字符串拼接其他方式\nlet string &#x3D; &quot;a-b-c-y&quot;;\nstring &#x3D; string.replace(&quot;a&quot;,a).replace(&quot;b&quot;,b).replace(&quot;b&quot;,b).replace(&quot;y&quot;,y);\n包含判断\nlet a &#x3D; 1;\nif(a &#x3D;&#x3D; 1 || a &#x3D;&#x3D; 2 || a &#x3D;&#x3D; 3)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n    \n&#x2F;&#x2F; 优化\nif([1, 2, 3].indexof(a) &gt;&#x3D; 0)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n\n数组的简写方式\nlet a &#x3D; new Array();\n\n&#x2F;&#x2F; 简写\nlet a &#x3D; [];\n箭头函数\n箭头函数就是函数的简写方式\nfunction doSomething(a, b)&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 以下仅仅@NApiVersion 2.0以上可以使用\n&#x2F;&#x2F; 简写\nlet doSomething &#x3D; (a, b) &#x3D;&gt; &#123;return a + b;&#125;;\n\n&#x2F;&#x2F; 箭头函数的两个省略\n&#x2F;&#x2F; 1.当箭头左边只有一个参数时,可省略()\na &#x3D;&gt; &#123;return a + 1;&#125;;\n&#x2F;&#x2F; 2.当箭头右边只有一句话时,可省略&#123;&#125;与return\n(a, b) &#x3D;&gt; a + b;\n对象的keys、values的使用\nlet student &#x3D; &#123;\n    name : 1,\n    classes : 3,\n&#125;;\n\n&#x2F;&#x2F; 获取对象的Keys\nObject.keys(student);   &#x2F;&#x2F; expected output: [&quot;name&quot;, &quot;classes&quot;]\n&#x2F;&#x2F; 获取对象的values\nObject.values(student); &#x2F;&#x2F; expected output: [1, 3]\n\n&#x2F;&#x2F; 判断对象是否具有该属性\nstudent.hasOwnProperty(&quot;classes&quot;);\nObject.keys(student).indexof(&quot;name&quot;) &gt;&#x3D; 0;\n\n数组的常用函数\n &#x2F;&#x2F; filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 \nconst words &#x3D; [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];\nconst result &#x3D; words.filter(word &#x3D;&gt; word.length &gt; 6);\nconsole.log(result);             &#x2F;&#x2F; expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]\n\n&#x2F;&#x2F; find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。\nconst array1 &#x3D; [5, 12, 8, 130, 44];\nconst found &#x3D; array1.find(element &#x3D;&gt; element &gt; 10);\nconsole.log(found);              &#x2F;&#x2F; expected output: 12\n\n&#x2F;&#x2F; forEach() 方法对数组的每个元素执行一次给定的函数。\nconst array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\narray1.forEach(element &#x3D;&gt; console.log(element));\n\n&#x2F;&#x2F; includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。\nconst array1 &#x3D; [1, 2, 3];\nconsole.log(array1.includes(2));   &#x2F;&#x2F; expected output: true\nconst pets &#x3D; [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;];\nconsole.log(pets.includes(&#39;cat&#39;)); &#x2F;&#x2F; expected output: true\nconsole.log(pets.includes(&#39;at&#39;));  &#x2F;&#x2F; expected output: false\n\n&#x2F;&#x2F; map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\nconst array1 &#x3D; [1, 4, 9, 16];     &#x2F;&#x2F; pass a function to map\nconst map1 &#x3D; array1.map(x &#x3D;&gt; x * 2);\nconsole.log(map1);                &#x2F;&#x2F; expected output: Array [2, 8, 18, 32]\n\n&#x2F;&#x2F; reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nconst array1 &#x3D; [1, 2, 3, 4];\nconst reducer &#x3D; (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue; \n&#x2F;&#x2F; 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer));                                       &#x2F;&#x2F; expected output: 10\n&#x2F;&#x2F; 5 + 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer, 5));                                    &#x2F;&#x2F; expected output: 15\n这些方法是ES6以上可以使用,但是我们想在ES6以下运用这些方法时,只需按照网址:\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n找到对应函数\n\npolyfill复制粘贴就能使用.\n字符串常用方法\n&#x2F;&#x2F; padEnd()  方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\n&#39;abc&#39;.padEnd(10);          &#x2F;&#x2F; &quot;abc       &quot;\n&#39;abc&#39;.padEnd(10, &quot;foo&quot;);   &#x2F;&#x2F; &quot;abcfoofoof&quot;\n&#39;abc&#39;.padEnd(6, &quot;123456&quot;); &#x2F;&#x2F; &quot;abc123&quot;\n&#39;abc&#39;.padEnd(1);           &#x2F;&#x2F; &quot;abc&quot;\n\n&#x2F;&#x2F; padStart() 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。\n&#39;abc&#39;.padStart(10);         &#x2F;&#x2F; &quot;       abc&quot;\n&#39;abc&#39;.padStart(10, &quot;foo&quot;);  &#x2F;&#x2F; &quot;foofoofabc&quot;\n&#39;abc&#39;.padStart(6,&quot;123465&quot;); &#x2F;&#x2F; &quot;123abc&quot;\n&#39;abc&#39;.padStart(8, &quot;0&quot;);     &#x2F;&#x2F; &quot;00000abc&quot;\n&#39;abc&#39;.padStart(1);          &#x2F;&#x2F; &quot;abc&quot;\n这些方法注意事项同上.\n优化的注意事项\n在优化之前我们要理解为什么要优化代码,所有的优化都是为了代码的可读性,但在某些情况下以上的例子不优化可能比优化的可读性要好\n例如\n&#x2F;&#x2F; 声明三个都是空的变量 \nlet name &#x3D; null;    &#x2F;&#x2F; 名称\nlet age &#x3D; null;     &#x2F;&#x2F; 年龄\nlet classes &#x3D; null; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n难道上面name, age, classes的声明方式比下面的优化语句,可读性差吗?并没有,但是当声明10个、20个、30个以上空的变量时,下面的优化语句就比上面的可读性强.\n当我们发现优化后并没有对可读性有提升时,就没必要优化.不过我们依然需要了解这些优化方式,以免我们需要增加代码可读性的时候,无从下手,或者不理解别人的代码.可读性不强的代码千千万万,优化的方式也多种多样,我们应当不放过自己可读性不强的代码,记住别人好的优化方式.各位还有别的案例或者优化方式,都可以自己更新这个文档,分享出来.\n网址的分享\nJavascript教程:https://wangdoc.com/javascript/index.html\nJS编程规范:https://github.com/airbnb/javascript/tree/es5-deprecated/es5\nECMAScript6入门:https://es6.ruanyifeng.com/?search=%E7%AE%AD%E5%A4%B4&amp;x=0&amp;y=0\nJavaScript帮助文档:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects\nwebStorm激活码获取:http://idea.94goo.com/\n","slug":"JavaScript","date":"2022-05-16T15:05:06.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"如峰"}]