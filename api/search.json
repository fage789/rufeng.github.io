[{"id":"eb06ef93065c8037d3e339961454164b","title":"分布式锁的使用","content":"引言分布式锁的作用就是在分布式系统中解决多个机器之间共享资源的排他性。而只要能够解决锁的排他性、可重入性、锁的获取与释放的方法、锁的失效机制及避免死锁。则就可以作为分布式锁使用\n使用Mysql作为分布式锁要实现分布式锁，最简单的方式就是直接创建一张锁表，然后通过操作该表中的数据来实现加锁和解锁。当要锁住某个方法或资源时，就向该表插入一条记录，表中设置方法名为唯一键，这样多个请求同时提交数据库时，只有一个操作可以成功，判定操作成功的线程获得该方法。创建这样的一张表CREATE TABLE &#96;method_lock&#96; (\n    &#96;id&#96; INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,\n    &#96;method_name&#96; VARCHAR(64) NOT NULL COMMENT &#39;方法名&#39;,\n    &#96;method_desc&#96; VARCHAR(1024) NOT NULL COMMENT &#39;方法描述&#39;,\n    &#96;create_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n    &#96;update_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,\n    PRIMARY KEY (&#96;id&#96;),\n    UNIQUE INDEX &#96;uniq_method_name&#96; (&#96;method_name&#96;)\n)\nCOMMENT&#x3D;&#39;分布式锁&#39;\nCOLLATE&#x3D;&#39;utf8_general_ci&#39;\nENGINE&#x3D;InnoDB;加锁insert into method_lock(method_name, method_desc) values(&quot;methodName&quot;, &quot;desc&quot;);\n解锁delete from method_lock where method_name &#x3D; &quot;methodName&quot;;以上：\n\n我们利用数据库将method_name做了唯一约束保证了排他性。\n要使用锁变为可重入的，则在数据库表中加个字段(thread_id)，记录当前获得锁的机器的主机信息和线程信息，获取锁的时候先查询数据库，如果已经获取了则直接分配给他就可以。\n这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。可以让数据库记录失效时间，使用定时任务清理。\n这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。可以循环多次去获取。\n\n总结数据库实现分布式锁的优点：\n\n直接借助数据库，容易理解\n\n数据库实现分布式锁的缺点：\n\n因为数据库本身的缺陷会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。\n操作需要一定的开销，性能问题需要考虑\n\n使用redis作为分布式锁在使用redis做分布式锁一般使用setnx + expire命令，即先用setnx来抢锁，如果抢到之后，再用expire给锁设置一个过期时间，防止锁忘记了释放。代码如下：if（jedis.setnx(key_resource_id,lock_value) &#x3D;&#x3D; 1）&#123; &#x2F;&#x2F;加锁\n    expire（key_resource_id，100）; &#x2F;&#x2F;设置过期时间\n    try &#123;\n        do something  &#x2F;&#x2F;业务请求\n    &#125;catch()&#123;\n  &#125;\n  finally &#123;\n       jedis.del(key_resource_id); &#x2F;&#x2F;释放锁\n    &#125;\n&#125;但是这个方案中setnx + expire命令并不是原子操作。为了保证原子性我们可以使用lu脚本或者SET的扩展命令(SET EX PX NX)\n\n\n\n\n\n\n\n\n\nSET key value[EX seconds][PX milliseconds][NX|XX]\n\nNX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。EX seconds :设定key的过期时间，时间单位是秒。PX milliseconds: 设定key的过期时间，单位为毫秒XX: 仅当key存在时设置值\n\n代码如下:if（jedis.set(key_resource_id, lock_value, &quot;NX&quot;, &quot;EX&quot;, 100s) &#x3D;&#x3D; 1）&#123; &#x2F;&#x2F;加锁\n    try &#123;\n        do something  &#x2F;&#x2F;业务处理\n    &#125;catch()&#123;\n  &#125;\n  finally &#123;\n       jedis.del(key_resource_id); &#x2F;&#x2F;释放锁\n    &#125;\n&#125;\n\n此时该方案的锁如果要保证可重入的，则set命令里需要加入线程ID，既可以保证只用加锁的线程能从删除也保证了锁的可重入性。Redisson框架中已经帮我们实现了这种功能\n有可能业务没执行完，超时时间到了，所以需要自动续期。Redisson框架中的看门狗帮我们实现了自动续期，以及续期上限\n如果redis是主从架构，则需要Redisson框架的redlock\n为了提高性能可以使用读写锁分离、以及分段锁\n\nZookeeper实现分布式锁Zookeeper一般使用临时顺序节点加watch监听器的方式实现分布式锁。比如客户端A创建临时节点node001,客户端A发现node001是临时顺序节点里最小的则获得锁，客户端B创建临时节点node002,发现node002不是最小节点，则客户端B开始等待，并在node001上创建监听器，当node001删除时，监听器通知客户端B，则客户端B获取到锁。\n","slug":"分布式锁的使用","date":"2022-10-11T15:30:06.000Z","categories_index":"分布式","tags_index":"分布式","author_index":"如峰"},{"id":"84a50db5bf041e6e7c87814a2cdda6c0","title":"InfluxDB1.0的入门","content":"下载安装InfluxDB下载地址：https://dl.influxdata.com/influxdb/releases/influxdb-1.5.4_windows_amd64.zip\n下载完成后修改influxdb.conf信息\n\n将[meta]里的dir修改为自己的地址\n将[data]里的dir修改为自己的地址\n\n运行InfluxDB服务通过CMD导航到所在文件夹，并执行命令启动服务&gt; E:\n&gt; CD E:\\influxdb\\influxdb1.5.4\\influxdb-1.5.4-1\n&gt; influxd.exe -config influxdb.conf\n再打开一个CMD，并执行influx&gt; E:\n&gt; CD E:\\influxdb\\influxdb1.5.4\\influxdb-1.5.4-1\n&gt; influx\n# 如果配置了自定义的端口号，使用\n&gt; influx -port 端口号\n下载安装可视化软件下载地址：https://github.com/CymaticLabs/InfluxDBStudio/releases/tag/v0.2.0-beta.1\n启动软件找到InfluxDBStudio.exe并双击\n常用SQL命令\n创建数据库\n\n-- 命令格式 create database &quot;db_name&quot;\nCREATE DATABASE NOAA_water_database;\n\n显示数据库\n\nshow databases;\n\n删除数据库\n\n-- 命令格式 drop database &quot;db_name&quot;\ndrop DATABASE NOAA_water_database; \n\n使用数据库\n\n-- 命令格式 use &quot;db_name&quot;\nuse NOAA_water_database; \n\n显示该数据库中所有的表\n\nshow measurements;\n\n创建表，直接在插入数据的时候指定表名\n\n-- 命令格式 insert test,host&#x3D;127.0.0.1,monitor_name&#x3D;test count&#x3D;1\nuse NOAA_water_database; \n\n删除表\n\n-- 命令格式 drop measurement &quot;measurement_name&quot;\nuse NOAA_water_database; \nCRUD示例测试数据导入通过CMD导航到，并执行下载命令再通过import进行导入 (如果使用默认端口号 -port 28086 需删除)\n&gt; E:\n&gt; CD E:\\influxdb\\influxdb1.5.4\\influxdb-1.5.4-1\n&gt; curl https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;noaa.water-database&#x2F;NOAA_data.txt -o NOAA_data.txt\n&gt; influx -port 28086 -import -path&#x3D;NOAA_data.txt -precision&#x3D;s -database&#x3D;NOAA_water_database\n启动influx，并测试查询\n&gt; SHOW measurements;\n\nname: measurements\n------------------\nname\naverage_temperature\nh2o_feet\nh2o_pH\nh2o_quality\nh2o_temperature\n查询数据计算water_level的非空值的数量h2o_feet&gt; SELECT COUNT(&quot;water_level&quot;) FROM h2o_feet\nname: h2o_feet\n--------------\ntime\t\t\t         count\n1970-01-01T00:00:00Z\t 15258选择测量h2o_feet中的前五个观测值：&gt; SELECT * FROM h2o_feet LIMIT 5\nname: h2o_feet\n--------------\ntime\t\t\t           level description\t   location\t       water_level\n2015-08-18T00:00:00Z\t   below 3 feet\t\t       santa_monica\t   2.064\n2015-08-18T00:00:00Z\t   between 6 and 9 feet\t   coyote_creek\t   8.12\n2015-08-18T00:06:00Z\t   between 6 and 9 feet\t   coyote_creek\t   8.005\n2015-08-18T00:06:00Z\t   below 3 feet\t\t       santa_monica\t   2.116\n2015-08-18T00:12:00Z\t   between 6 and 9 feet\t   coyote_creek\t   7.887\n删除数据&gt; delete FROM &quot;h2o_feet&quot; where &quot;time&quot; &#x3D; &#39;2019-08-17T00:00:00Z&#39;\n增加数据# 通过\\ 解决KEY值分开的问题\n&gt; insert h2o_feet,location&#x3D;coyote_creek water_level&#x3D;10.99,level\\ description&#x3D;&quot;below 3 feet&quot; 1662692351221478600\n修改数据# 时间戳与tag必须与修改数据一致\n&gt; insert h2o_feet,location&#x3D;coyote_creek water_level&#x3D;10.98,level\\ description&#x3D;&quot;below 3 feet&quot; 1662692351221478600\n数据来源和注意事项样本数据是来自美国国家海洋和大气管理局 (NOAA) 业务海洋产品和服务中心的公开数据。这些数据包括 2015 年 8 月 18 日至 2015 年 9 月 18 日期间在两个站点（加利福尼亚州圣莫尼卡 (ID 9410840) 和加利福尼亚州 Coyote Creek (ID 9414575)）每六分钟收集的 15,258 次水位 (ft) 观测值.\n请注意，测量值average_temperature、h2o_pH、h2o_quality和h2o_temperature包含虚构数据。这些测量有助于阐明Schema Exploration中的查询功能。\n该h2o_feet测量是唯一包含NOAA数据的测量。请注意，该level description字段不是原始NOAA数据的一部分 - 我们将其隐藏在其中是为了获得具有特殊字符和字符串字段值的字段键。\nInfluxDB在Java中的使用引入Maven依赖&lt;dependency&gt;\n    &lt;groupId&gt;org.influxdb&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;influxdb-java&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.18&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n客户端连接&#x2F;&#x2F; 数据库连接地址\nprivate final static String serverURL &#x3D; &quot;http:&#x2F;&#x2F;localhost:28086&quot;;\n&#x2F;&#x2F; 账号名\nprivate final static String username &#x3D; &quot;admin&quot;;\n&#x2F;&#x2F; 密码\nprivate final static String password &#x3D; &quot;123456&quot;;\n&#x2F;&#x2F; 数据库名称\nprivate final static String databaseName &#x3D; &quot;NOAA_water_database&quot;;\n\n&#x2F;&#x2F; 创建连接\nInfluxDB influxDB &#x3D; InfluxDBFactory.connect(serverURL, username, password);\n新增数据&#x2F;&#x2F; 插入数据\nPoint build &#x3D; Point.measurement(&quot;h2o_feet&quot;)\n        .tag(&quot;location&quot;, &quot;coyote_creek&quot;)\n        .addField(&quot;water_level&quot;, 10.9)\n        .addField(&quot;level description&quot;, &quot;below 3 feet&quot;).build();\ninfluxDB.write(databaseName, &quot;&quot;, build);\n删除数据&#x2F;&#x2F; 删除数据\nQuery query &#x3D; new Query(&quot;delete FROM \\&quot;h2o_feet\\&quot; where \\&quot;time\\&quot; &#x3D; &#39;2019-08-17T00:00:00Z&#39;&quot;, databaseName);\ninfluxDB.query(query, 0, queryResult -&gt; &#123;\n    System.out.println(queryResult.getResults());\n&#125;);\n修改数据 &#x2F;&#x2F; 修改数据 时间戳与需修改数据的时间戳与tag必须一样 santa_monica\nPoint build &#x3D; Point.measurement(&quot;h2o_feet&quot;)\n        .tag(&quot;location&quot;, &quot;coyote_creek&quot;)\n        .addField(&quot;water_level&quot;, 10.9)\n        .addField(&quot;level description&quot;, &quot;below 3 feet&quot;).build();\ninfluxDB.write(databaseName, &quot;&quot;, build);\n查询数据&#x2F;&#x2F; 删除数据\nQuery query &#x3D; new Query(&quot;delete FROM \\&quot;h2o_feet\\&quot; where \\&quot;time\\&quot; &#x3D; &#39;2019-08-17T00:00:00Z&#39;&quot;, databaseName);\ninfluxDB.query(query, 0, queryResult -&gt; &#123;\n    System.out.println(queryResult.getResults());\n&#125;);\nInfluxDB的关键概念InfluxDB专为时间序列数据而构建。关系数据库可以处理时间序列数据，但没有针对常见的时间序列工作负载进行优化。InfluxDB旨在存储大量时间序列数据并快速对该数据执行实时分析。\ntime就是主键在InfluxDB中，时间戳标识就是主键。这就像一个SQL数据库表，其中主键是系统预先设置的，并且始终是时间戳。\n关键词汇\ndatabase 同MySQL都代表数据库\nmeasurement 同MySQL中的表\npoint 同MySQL中的一行数据\ntime 数据库记录的时间是主键，自动生成\nfield 可以理解为MySQL中非索引column\ntag 可以理解为MySQL中索引column\nseries measurement相同、field的key相同、tag的key、value相同的数据集\n\nInfluxDB不是CRUDInfluxDB是一个针对时间序列数据进行了优化的数据库。这些数据通常来自分布式传感器组、大型网站的点击数据或金融交易列表等来源。这些数据的一个共同点是它在聚合中更有用。一篇文章说您的计算机的CPU在星期二 12:38:35 UTC 的利用率为 12%，很难从中得出结论。当与该系列的其余部分结合并可视化时，它会变得更加有用。这是随着时间的推移开始显示趋势的地方，并且可以从数据中得出可行的见解。另外，时序数据一般只写一次，很少更新。结果是InfluxDB不是一个完整的CRUD数据库，而是更像一个CR-ud，将创建和读取数据的性能优先于更新和销毁，并防止一些更新和销毁行为以使创建和读取性能更高：\n\n要更新一个点，请插入一个具有相同measurement、tag和timehe的点。\n您可以删除或删除一个系列，但不能基于字段值删除单个点。作为一种解决方法，您可以搜索字段值，检索时间，然后根据time字段删除。\n您还不能更新或重命名标签 - 请参阅 GitHub 问题#4157了解更多信息。要修改一系列点的标记，请找到具有违规标记值的点，将值更改为所需的值，将点写回，然后删除具有旧标记值的系列。\n您不能按tag删除tags -请参阅 GitHub 问题 #8604。\n\n设计表上的注意点\n将查询、分组中常用的值作为tag字段，其它不常用的使用field字段\n不要创建过多的tag字段，这意味着按标签查询比按字段查询更高效。但是当创建的索引过多时，写入和读取都可能开始变慢。\n使用推荐的命名约定\n避免在标签和字段键中保留关键字\n避免标签和字段使用相同的名称\n避免在测量和键中编码数据\n\n\n\n\n\n\n\n\n\n\n\n\n详细文档可查看官方文档 https://docs.influxdata.com/influxdb/v1.8/concepts/schema_and_data_layout/#avoid-reserved-keywords-in-tag-and-field-keys关于InfluxDB设计上的见解和权衡可参考官方文档https://docs.influxdata.com/influxdb/v1.8/concepts/insights_tradeoffs/\n","slug":"InfluxDB的入门","date":"2022-09-11T15:30:06.000Z","categories_index":"InfluxDB","tags_index":"InfluxDB","author_index":"如峰"},{"id":"d1bd2738cb3df5b91e8dbed191b9a6e0","title":"java开发手册一面向对象","content":"声明此文章根据书籍《码出高效：Java开发手册》整理的读后笔记。仅交流学习使用。\n引言面向对象编程(ec -Ori te Programming, OOP)是划时代的编程思想变革，推动了高级语言的快速发展和工业化进程。OOP的抽象、封装、继承、多态的理念使软件大规模化成为可能，有效地降低了软件开发成本、维护成本和复用成本。面向对象编程思想完全不同于传统的面向过程编程思想，使大型软件的开发就像措积木样隔离可控、高效简单 是当今编程领域的一股势不可当的潮流。 OOP实践了软件工程的三个主要目标可维护性、可重用性和可扩展性。甚至JavaScript从ES6后也开始加入class等关键词，朝OOP靠拢。\nOOP理念传统意义上面向对象有三大特性封装、继承、多态。本书明确将抽象为面向对象的特性之一，支持面向对象“四大特性”的说法。\n抽象Java之父Gosling设计的Object类，是任何类的默认父类，是对万事万物的抽象，高度概括了事物的自然行为和社会行为。我们都知道哲学的三大经典问题我是谁，我从哪里来，我到哪里去。在Object类中，这些问题都可以得到隐约的解答。\n\n我是谁: getClass()说明本质上是谁，而toString()是当前职位的名片。\n我从哪里里来: Object()构造方法是生产对象的基本步骤， clone()是繁殖对象的另一种方式\n我到哪里去: finalize()是在对象销毁时触发的方法。\n世界是否因你不同: hashCode()、equals()就是判断与其他元素是否相同的组方法。\n与他人枉何协调: wait()和notify()是对象间通信与协作的一组方法。\n\n\n\n\n\n\n\n\n\n\n随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如finalize()方法在JDK9之后直接被标记为过时方法。而wait()和 notify()同步方式事实上已经被同步信号、锁、阻塞集合等取代。\n浅拷贝与深拷贝\n浅拷贝：只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指向的实际对象。\n彻底深拷贝：是在成功clone一个对象之后，此对象与母对象在任何引用路径上都不存在共享的实例对象，但是引用路径递归越深，则越接近JVM对象，且发现彻底深拷贝实现难度越大。\n深拷贝：介于浅拷贝和彻底深拷贝之间的都是一般深拷贝\n\n\n\n\n\n\n\n\n\n\n慎用Object.clone()方法来拷贝对象，因为对象的clone()方法默认是浅拷贝，若想实现深拷贝，则需要覆写clone()方法实现引用对象的深度遍历式拷贝。作者认为彻底深拷贝是与深拷贝不同的，但是实际中我们会认为深拷贝就是彻底深拷贝。就例如0.999…无限循环小数和1(或者固定位数的0.99..)在数学里是不等的，但是在生活中为了方便我们会认为0.999…无限循环小数约等于1(或者固定位数的0.99..)，即两者是相等的。\n封装封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的方式暴露哪些信息。抽象是要找到属性和行为的共性，属性是行为的基本生产资料，具有一定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行，某些敏感方法或者外部不需要感知的复杂逻辑处理，一般也会进行封装。封装使面向对象的耦合度变弱，有利于维护。而在Java中就是通过设置属性为private或者其它访问等级，限制属性的访问，让外部只能通过getter/setter去访问属性。\n继承继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系形成一个继承树，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复用或增强复用，父类的能力通过这种方式赋予子类。继承把枯燥的代码世界变得更有层次感，更有扩展性，为多态打下语法基础。\n\n\n\n\n\n\n\n\n\n继承是is-a的关系。判断标准即是否符合里氏代换原则(Liskov Substitution Principle, LSP)。LSP是指任何父类能够出现的地方，子类都能够出现。从字面上很难深入理解，先打个比方警察在枪战片中经常说放下武器，把手举起来！而对面的匪徒们有的使用手枪，有的使用匕首，这些都是武器的子类。父类出现的地方，即“放下武器” 那么，放下手枪，是对的，放下匕首，也是对的。在实际代码环境中，如果父类引用直接使用子类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期，那么说明两个类之间符合LSP原则，可以使用继承关系。\n多态多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个方法产生不同的运行结果，使同一个行为具有不同的表现形式。多态提升了对象的扩展能力和运行时的丰富想象力。而重写和重载就是多态的实现方式。\n重载和重写\n重写：是子类实现接口或者继承父类时，保持方法签名完全相同，实现不同的方法体，是垂直方向上行为的不同体现。是运行上的多态性。重写时遵循两同两小一大原则。\n两同：方法名相同，参数列表相同\n两小：子类返回值类型小于等于父类返回值类型(返回值为基本数据类型时，必须相等);子类抛出的异常小于等于父类抛出的异常\n一大：子类访问控制修饰符大于等于父类访问控制修饰符\n\n\n重载：方法名称相同但是参数类型或参数个数是不相同的，不考虑修饰符以及返回值，是水平上行为的不同体现。是编译上的多态性。\n\n","slug":"Java开发手册—面向对象","date":"2022-07-18T15:30:06.000Z","categories_index":"面向对象","tags_index":"Java","author_index":"如峰"},{"id":"44c25000734936b0a1dbcbaacbd8e114","title":"Mysql索引失效的几种情况","content":"引言索引在我们使用Mysql数据库时可以极大的提高效率，然而有时候因为使用上的问题导致索引失效。现在我们看看有哪几种情况索引失效。\n转换索引数据类型不一致SELECT * FROM user WHERE height&#x3D; 180; &#x2F;&#x2F; 其中height是varchar类型\n因为height是varchar类型，而where条件180是Number类型，数据类型不一致，索引失效。\n数据的字符集不一致SELECT * FROM oc_order oo join orders_detail od ON oo.order_id &#x3D; od.order_id; &#x2F;&#x2F; 其中oo.order_id是utf8mb4, od.order_id是utf8字符集\n因为oo.order_id与od.order_id，使用的字符集不一致，索引失效。\n索引使用函数SELECT * FROM user WHERE DATE(create_time) &#x3D; &#39;2020-09-03&#39;; &#x2F;&#x2F; create_time是索引字段\n对索引字段create_time使用了DATE()函数，导致索引失效\n索引使用了表达式计算SELECT * FROM user WHERE age - 1 &#x3D; 20;\n对索引字段age使用了-法运算，导致索引失效\n\n\n\n\n\n\n\n\n\n总结其中索引使用了函数、表达式计算，对索引做了转换，导致索引的排序失效而不走索引，其中字符集不一致、类型不一致，导致Mysql做了隐式转换，导致索引的排序失效而不走索引\n索引使用了不等于判断select num from student where student_id &lt;&gt; 10 ;       &#x2F;&#x2F; 不走索引\n\nselect num from student where student_id !&#x3D; 10 ;       &#x2F;&#x2F; 不走索引\n\nselect num from student where student_id is not Null ; &#x2F;&#x2F; 不走索引\n\nselect num from student where student_id is Null ;     &#x2F;&#x2F; 走索引\n其中&lt;&gt;、!= 的不相等判断时，B+树查找不等于时，只能一个个查找进行判断，而 is not Null是不等于Null所以不走索引，而is Null是等于Null所以走索引\n\n\n\n\n\n\n\n\n\n不相等判断B+树必须全表扫描导致索引失效\n违反最左原则最左前缀原则：\n\n即如果你创建一个联合索引, 那 这个索引的任何前缀都会用于查询, (col1, col2, col3)这个联合索引的所有前缀 就是(col1), (col1, col2), (col1, col2, col3), 包含这些列的查询都会启用索 引查询.\n其他所有不在最左前缀里的列都不会启用索引, 即使包含了联合索引里的部分列 也不行. 即上述中的(col2), (col3), (col2, col3)都不会启用索引去查询.\n\norder Byselect * from user where name &#x3D; &#39;zhangsan&#39; and age &#x3D; 20 order by age,pos; &#x2F;&#x2F; 其中(age,pos)为联合索引, 走索引\n\nselect name,age from user where name &#x3D; &#39;zhangsan&#39; order by pos;          &#x2F;&#x2F; 违反最左前缀原则, 不走索引\n\n违反最左前缀法则，不仅索引失效，而且导致额外的文件排序（会降低性能）。\ngroup Byselect * from user where name &#x3D; &#39;zhangsan&#39; and age &#x3D; 20 order by age,pos; &#x2F;&#x2F; 其中(age,pos)为联合索引, 走索引\n\nselect name,age from user where name &#x3D; &#39;zhangsan&#39; order by pos;           &#x2F;&#x2F; 违反最左前缀原则, 不走索引\n违反最左前缀法则，不仅索引失效，而且导致产生临时表（会降低性能）。\nlikeselect id,address from t_user where address like &#39;%海淀区%&#39;; &#x2F;&#x2F; 不走索引\nselect id,address from t_user where address like &#39;海淀区%&#39;;  &#x2F;&#x2F; 走索引\nselect id,address from t_user where address like &#39;%海淀区&#39;;  &#x2F;&#x2F; 不走索引\n%在字段的左边则会不符合最左原则，导致索引失效\norselect * from user where name = &#39;zhangsan&#39; or age = 20; // 其中age不是索引\n`\n\n如果or要使用索引，必须or左右两边都是索引字段。当然如果or左右两边都是索引字段，但是Mysql判断走全表扫描快也不会走索引。\n\n\n\n\n\n\n\n注意\n当Mysql判断全表扫表比走索引快时索引也会失效\n\n\n","slug":"Mysql索引失效的几种情况","date":"2022-06-14T03:30:06.000Z","categories_index":"Mysql","tags_index":"MySQL","author_index":"如峰"},{"id":"2c03d9b1a2276865a0e94d2f6eb59bcd","title":"Mysql索引 - 为什么使用B+树","content":"引言通过分析哈希索引、平衡二叉树、B树、B+树来判断Mysql为什么使用B+树。\n\n\n\n\n\n\n\n\n\n其中文章中使用的数据结构可视化地址能够更好的帮助大家了解这四种索引方式。\n哈希树通过哈希算法计算值的键，以键值对的方式存储数据。\n\n可以看到插入了[0，1，2，3，4，55]，而[3，55]的哈希值相同而放在同一键下，并以链式的方式存储。这种方式查找单个值十分迅速，只需反向计算出哈希值就能定位到键并通过键找到值。但是因为哈希值是没有顺序的所以没有办法进行范围查找，而且有可能有些值得到的哈希值相同。\n平衡二叉树平衡树指的是，任意节点的子树的高度差都小于等于1。\n\n可以看到插入0~10，生成了一棵深度为三的树，当我们查询3的时候需要查询2次:\n\n3 &lt; 4进入到左边节点向下查询\n3 &gt; 2进入到右边节点向下查询，右边节点等于三，则停止\n\n因此查询速度是由这棵树的深度决定，数据量越大则深度越大，速度越慢，且范围查找十分困难。\nB树是一个节点可以存储超过2个元素、可以拥有超过2个子节点的多路平衡查找树\n\n可以看到插入0 ~ 14，生成了一棵深度为三的树，当我们查询3的时候需要查询2次，搜索方式也是和平衡二叉树相似\n\n先在节点内部从小到大（从左到右）开始搜索元素，如果命中，搜索结束;\n如果未命中，再去对应的子节点中搜索元素，然后重复步骤\n\n它的缺点是每个节点都存储了索引和业务数据，业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及CPU高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，现在却要多次才能加载完。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃，如果十分占内存可能每个节点能存储的数据相当少导致深度变大，速度变慢，且范围查找也十分不方便\nB+树B+ 树就是为了拆分索引数据与业务数据的平衡多叉树。相比B树非叶子节点不记录业务数据，且叶子节点根据顺序互相链接。\n\n可以看到插入0 ~ 10，生成了一棵深度为三的树，当我们查询3的时候需要查询2次，因为根节点和子节点不存储业务数据，则非叶子节点能够存储的元素就相当多，保证深读不会多大，且叶子节点会互相链接，范围查找就相当方便，例如要查找 &gt;2的数据，只需找到2并根据链接向右查找。\nMysql的主键树如图：\n\n可以看到树从上到下从左到右都是有顺序的，所以这也是Mysql的ID优先使用主键自增，而不使用UUID。因为使用UUID当遇到插入、删除时，可能需要重新排序，而到导致需要修改整颗，十分耗时。如果Mysql里没有创建ID，则会默认创建一个隐式主键Id，用来创建B+树，而创建其它索引时，也会根据此索引创建B+树，但是叶子节点存储的业务数据是主键，所以根据索引查找数据时，将会查找两次树，一次在索引B+树上找到主键，再在主键B+树上查找数据。而这颗索引树也是会消耗空间和维护成本，所以不要在不必要的时候去创建索引，而且索引也尽量最小化。 \nMysql的B+树总结\n\n\n\n\n\n\n\n\n\nB+树从左至右，从上到下索引都是按照一定的顺序做排列，提高了查询速度\n非叶子节点不存储业务数据，大大增加了非叶子节点存储的元素，减少了树的深度，提高了查询速度\n叶子节点会根据顺序相互链接，提高了范围查找的方便性\n主键不使用UUID，使用自增ID，减少了插入、删除时需要重排，导致修改整颗树的可能性，减少了维护成本\nMysql的表人为的不创建主键， Mysql会隐式的创建主键\n创建的索引会创建一颗索引B+树，消耗空间且提高了维护成本，所以非必要时不要创建索引\n索引B+树叶子节点不存业务数据只存储主键，会根据主键再次查找数据\n\n","slug":"Mysql索引为什么使用B+树","date":"2022-06-13T08:30:06.000Z","categories_index":"Mysql","tags_index":"MySQL","author_index":"如峰"},{"id":"135ff637d6fd3260ea45b1df53f84b3e","title":"Java Optional的使用","content":"引言Optional类是Java8为了解决null值判断问题，借鉴google guava类库的Optional类而引入的一个同名Optional类，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。\n以前我们public static String getGender(Student student)&#123;\n    if(null &#x3D;&#x3D; student)&#123;\n        return &quot;Unkown&quot;;\n    &#125;\n    return student.getGender();   \n&#125;\n现在\npublic static String getGender(Student student)&#123;\n    \n    return Optional.ofNullable(student)   &#x2F;&#x2F; 创建一个student可能为空的Optional\n                .map(u -&gt; u.getGender())  &#x2F;&#x2F; 如果student有值则返回学生的信息\n                .orElse(&quot;Unkown&quot;);        &#x2F;&#x2F; 如果返回值为空则返回&quot;Unkown&quot;\n&#125;\nOptional的创建声明一个空的OptionalOptional&lt;Car&gt; optCar = Optional.empty();\n依据一个非空值创建OptionalOptional&lt;Car&gt; optCar = Optional.of(car);\n\n\n\n\n\n\n\n\n\n如果car是一个null，这段代码会立即抛出一个NullPointerException，而不是等到你试图访问car的属性值时才返回一个错误。\n可接受null的OptionalOptional&lt;Car&gt; optCar = Optional.ofNullable(car)\n\n\n\n\n\n\n\n\n\n如果car是null，那么得到的Optional对象就是个空对象\nOptional的方法\n\n\n\n方法\n描述\n\n\n\n\nstatic &lt;T&gt; Optional&lt;T&gt; empty()\n返回空的 Optional 实例。\n\n\nboolean equals(Object obj)\n判断其他对象是否等于 Optional。\n\n\nOptional&lt;T&gt; filter(Predicate&lt;? super &lt;T&gt; predicate)\n如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。\n\n\n&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)\n如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional。\n\n\nT get()\n如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException\n\n\nint hashCode()\n返回存在值的哈希码，如果值不存在 返回 0。\n\n\nvoid ifPresent(Consumer&lt;? super T&gt; consumer)\n如果值存在则使用该值调用 consumer , 否则不做任何事情。\n\n\nboolean isPresent()\n如果值存在则方法会返回true，否则返回 false。\n\n\n&lt;U&gt;Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper)\n如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。\n\n\nstatic &lt;T&gt; Optional&lt;T&gt; of(T value)\n返回一个指定非null值的Optional。\n\n\nstatic &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)\n如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。\n\n\nT orElse(T other)\n如果存在该值，返回值， 否则返回 other。\n\n\nT orElseGet(Supplier&lt;? extends T&gt; other)\n如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。\n\n\n&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)\n如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常。\n\n\nString toString()\n返回一个Optional的非空字符串，用来调试。\n\n\n\n\nOptional的示例从Optional对象中提取和转换值person.flatMap(Person::getCar)  &#x2F;&#x2F; 获取员工的汽车对象\n    .flatMap(Car::getInsurance) &#x2F;&#x2F; 获取汽车的保险公司对象\n    .map(Insurance::getName)    &#x2F;&#x2F; 获取保险公司名称\n    .orElse(&quot;Unknown&quot;);         &#x2F;&#x2F; 如果Optional的结果值为空，设置默认值\n\n\n\n\n\n\n\n\n\n不用以前层层判断对象是否为空，再继续执行代码了\n使用filter剔除特定的值以前Insurance insurance &#x3D; ...; \nif(insurance !&#x3D; null &amp;&amp; &quot;CambridgeInsurance&quot;.equals(insurance.getName()))&#123; \n    System.out.println(&quot;ok&quot;); \n&#125;使用Optional对象的filter方法，这段代码可以重构如下:\nOptional&lt;Insurance&gt; optInsurance &#x3D; ...; \noptInsurance.filter(insurance -&gt; &quot;CambridgeInsurance&quot;.equals(insurance.getName())) &#x2F;&#x2F; 根据条件过滤值\n    .ifPresent(x -&gt; System.out.println(&quot;ok&quot;));                                     &#x2F;&#x2F; 如果值存在则打印输出\n    ","slug":"Java Optional的使用","date":"2022-06-08T06:30:06.000Z","categories_index":"java,Optional","tags_index":"java,Optional","author_index":"如峰"},{"id":"c89fcf3f80f5323c4d2b7488e0aabc7d","title":"Java文档注释","content":"引言Java 支持三种注释方式。前两种分别是 // 和 /* */，第三种被称作说明注释，它以 /** 开始，以 */结束。说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。说明注释，使你更加方便的记录你的程序信息。\nJavaDoc标签\n\n\n\n标签\n描述\n示例\n\n\n\n\n@author\n标识一个类的作者\n@author description\n\n\n@deprecated\n指名一个过期的类或成员\n@deprecated description\n\n\n{@docRoot}\n指明当前文档根目录的路径\nDirectory Path\n\n\n@exception\n标志一个类抛出的异常\n@exception exception-name explanation\n\n\n{@inheritDoc}\n从直接父类继承的注释\nInherits a comment from the immediate surperclass.\n\n\n{@link}\n插入一个到另一个主题的链接\n{@link name text}\n\n\n{@linkplain}\n插入一个到另一个主题的链接，但是该链接显示纯文本字体\nInserts an in-line link to another topic.\n\n\n@param\n说明一个方法的参数\n@param parameter-name explanation\n\n\n@return\n说明返回值类型\n@return explanation\n\n\n@see\n指定一个到另一个主题的链接\n@see anchor\n\n\n@serial\n说明一个序列化属性\n@serial description\n\n\n@serialData\n说明通过writeObject( ) 和 writeExternal( )方法写的数据\n@serialData description\n\n\n@serialField\n说明一个ObjectStreamField组件\n@serialField name type description\n\n\n@since\n标记当引入一个特定的变化时\n@since release\n\n\n@throws\n和 @exception标签一样.\nThe @throws tag has the same meaning as the @exception tag.\n\n\n{@value}\n显示常量的值，该常量必须是static属性。\nDisplays the value of a constant, which must be a static field.\n\n\n@version\n指定类的版本\n@version info\n\n\n\n\n内嵌HTMLpre标签&lt;pre&gt;&lt;/pre&gt;标签会保留原文档的格式。当文档需要换行、空格时可以使用此标签\n&#x2F;&#x2F; javadoc&#x2F;Documentation2.java\n&#x2F;** &lt;pre&gt;\n* System.out.println(new Date());\n* &lt;&#x2F;pre&gt;\n*&#x2F;\npublic class Documentation2 &#123;&#125;\n其它HTML标签我们还可以使用HTML来格式化说明中的文字\n&#x2F;&#x2F; javadoc&#x2F;Documentation3.java\n&#x2F;** You can &lt;em&gt;even&lt;&#x2F;em&gt; insert a list:\n* &lt;ol&gt;\n* &lt;li&gt; Item one\n* &lt;li&gt; Item two\n* &lt;li&gt; Item three\n* &lt;&#x2F;ol&gt;\n*&#x2F;\npublic class Documentation3 &#123;&#125;\n\n\n\n\n\n\n\n\n\n请注意，在文档注释中，Javadoc会删除行首的星号以及前导空格。 Javadoc重新格式化了所有内容，使其符合文档的标准外观。不要将&lt;h1&gt; 和&lt;hr&gt; 之&gt;类的标题用作嵌入式HTML，因为Javadoc会插入自己的标题，你插入的标题将对其产生干扰。\n常用说明注释标签@see这个标签可以将其它的类链接到本文档中。Javadoc 用 @see 标签产生链接到其它类的的HTML。这个标签可以将其它的类链接到本文档中。Javadoc 用 @see 标签产生链接到其它类的的HTML。\n&#x2F;&#x2F; @see必须顶头写,前面不能有任何内容\n@see classname                             &#x2F;&#x2F; 类名\n@see fully-qualified-classname             &#x2F;&#x2F; 完全限定类名\n@see fully-qualified-classname#method-name &#x2F;&#x2F; 完全限定类名#方法名\n&#x2F;&#x2F; 链接跳转地址\n@see &lt;a href&#x3D;&quot;[https:&#x2F;&#x2F;](https:&#x2F;&#x2F;www.runoob.com&#x2F;java&#x2F;java-documentation.html)&quot;&gt;JavaDoc菜鸟教程&lt;&#x2F;a&gt;\n\n&#x2F;**\n * @see Student\n * @see top.join.Student\n * @see Student#getStudentId()\n *&#x2F;\npublic class DataExample()&#123;&#125;\n{@link}与{@linkplain}与@see非常相似，不同之处在于它们可以内联使用(不同顶头写)，并使用标签作为超链接文本。不过&#123;@linkplain&#125;可以自定义显示文本\n&#x2F;&#x2F; &#123;@link&#125;无需顶头写\n中文&#123;@link classname&#125;中文                      &#x2F;&#x2F; 类名\n&#123;@link fully-qualified-classname&#125;             &#x2F;&#x2F; 完全限定类名\n&#123;@link fully-qualified-classname#method-name&#125; &#x2F;&#x2F; 完全限定类名#方法名\n&#123;@linkplain classname 文本内容&#125;\n&#x2F;&#x2F; 链接跳转地址\n&#123;@link &lt;a href&#x3D;&quot;[https:&#x2F;&#x2F;](https:&#x2F;&#x2F;www.runoob.com&#x2F;java&#x2F;java-documentation.html)&quot;&gt;JavaDoc菜鸟教程&lt;&#x2F;a&gt;&#125;\n\n&#x2F;**\n * 学生&#123;@link Student&#125;\n * &#123;@link top.join.Student&#125;\n * &#123;@link Student#getStudentId()&#125;\n * &#123;@linkplain Student 学生&#125;\n *&#x2F;\npublic class DataExample()&#123;&#125;\n@version用于标记当前版本，默认为1.0\n@since一般用于标记文件创建时项目当时对应的版本，一般后面跟版本号，也可以跟是一个时间，表示文件当前创建的时间\n@throws一个方法可以产生许多不同类型的异常，所有这些异常都需要描述。\n@throws fully-qualified-class-name description &#x2F;&#x2F; 完全限定类名 异常描述\n\n&#x2F;**\n *\n * @throws IllegalArgumentException when the given source contains invalid encoded sequences\n *&#x2F;\n@deprecated指名一个过期的类或方法,所以一定要说明为什么过期或者用什么方法做替换\n{@value}用于标注在常量上，{@value} 用于表示常量的值\n\n&#x2F;**\n * \n * 用在类上需要指定是哪一个常量\n * 默认数量1 &#123;@value QTY_A&#125; \n * 默认数量2 &#123;@value QTY_B&#125;  \n *&#x2F;\npublic class DataExample &#123;\n\n    &#x2F;** 默认数量1 &#123;@value&#125;*&#x2F;\n    public final static Integer QTY_A &#x3D; 1;\n    &#x2F;** 默认数量2 &#123;@value&#125;*&#x2F;\n    public final static Integer QTY_B &#x3D; 1;\n&#125;    \ncode&#123;@code text&#125; 会被解析成&lt;code&gt; text &lt;/code&gt;将文本标记为代码样式的文本，在code内部可以使用 &lt; 、&gt; 等不会被解释成html标签, code标签有自己的样式。一般在Javadoc中只要涉及到类名或者方法名，都需要使用@code进行标记。\n&#x2F;**\n * Check whether the given &#123;@code CharSequence&#125; contains actual &lt;em&gt;text&lt;&#x2F;em&gt;.\n * &lt;p&gt;More specifically, this method returns &#123;@code true&#125; if the\n * &#123;@code CharSequence&#125; is not &#123;@code null&#125;, its length is greater than\n * 0, and it contains at least one non-whitespace character.\n * &lt;p&gt;&lt;pre class&#x3D;&quot;code&quot;&gt;\n * StringUtils.hasText(null) &#x3D; false\n * StringUtils.hasText(&quot;&quot;) &#x3D; false\n * StringUtils.hasText(&quot; &quot;) &#x3D; false\n * StringUtils.hasText(&quot;12345&quot;) &#x3D; true\n * StringUtils.hasText(&quot; 12345 &quot;) &#x3D; true\n * &lt;&#x2F;pre&gt;\n * @param str the &#123;@code CharSequence&#125; to check (may be &#123;@code null&#125;)\n * @return &#123;@code true&#125; if the &#123;@code CharSequence&#125; is not &#123;@code null&#125;,\n * its length is greater than 0, and it does not contain whitespace only\n * @see Character#isWhitespace\n *&#x2F;\npublic static boolean hasText(@Nullable CharSequence str) &#123;\n\treturn (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; containsText(str));\n&#125;","slug":"Java文档注释","date":"2022-06-07T10:30:06.000Z","categories_index":"java,注释","tags_index":"java,注释","author_index":"如峰"},{"id":"21734e1cbf39a356733db81c004c61e6","title":"Java Stream 流式编程","content":"引言流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，你无需写任何多线程代码了！\n流创建通过集合&#x2F;&#x2F; 创建一个集合\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n&#x2F;&#x2F; 得到一个顺序流\nStream&lt;Integer&gt; stream &#x3D; list.stream();\n&#x2F;&#x2F; 得到一个并行了流\nStream&lt;Integer&gt; parallelStream &#x3D; list.parallelStream();\n通过数组&#x2F;&#x2F; 先创建一个数组\nint[] arr &#x3D; new int[]&#123;1, 2, 3, 4, 5, 6&#125;;\n&#x2F;&#x2F; 使用数组Arrays工具类获取Stream流\nIntStream stream &#x3D; Arrays.stream(arr);\n通过ofStream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5,6);\n创建无限流&#x2F;&#x2F; 无限流之迭代方式\n&#x2F;&#x2F; 创建了10个元素从0到18, 第一个参数是初始值、第二个参数决定下一个生成值的规则\nStream&lt;Integer&gt; streamI &#x3D;  Stream.iterate(0, t -&gt; t + 2).limit(10);\n        \n&#x2F;&#x2F; 无限流之生成方式\n&#x2F;&#x2F; 创建了10个随机数\nStream&lt;Double&gt; streamG &#x3D;  Stream.generate(Math::random).limit(10);\n构造器模式Stream&lt;Integer&gt; stream &#x3D; Stream.&lt;Integer&gt;builder().add(1).add(2).build();\nstream.forEach(System.out::print);\n流的常用操作中间操作与终端操作java.util.stream.Stream中的Stream接口定义了许多操作。它们可以分为两大类。我们来看一下例子：\nList&lt;String&gt; names &#x3D; menu.stream() \n    .filter(d -&gt; d.getCalories() &gt; 300)\n    .map(Dish::getName) \n    .limit(3) \n    .collect(toList()); \n\n你可以看到两类操作：\n\nfilter、map和limit可以连成一条流水线；\ncollect触发流水线执行并关闭它。\n\n\n\n\n\n\n\n\n可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。\n\n\n\n\n\n\n\n\n\n警告\n使用终端操作代表消费流结束,想要重新消费必须重新构建流。\n\n\n常用操作API\n\n\n\n操作\n类型\n返回类型\n操作参数\n函数描述符\n功能描述\n\n\n\n\nfilter\n中间\nStream&lt;T&gt;\nPredicate&lt;T&gt;\nT -&gt; boolean\n过滤\n\n\ndistinct\n中间\nStream&lt;T&gt;\n\n\n去重\n\n\nskip\n中间\nStream&lt;T&gt;\nlong\n\n跳过元素\n\n\nlimit\n中间\nStream&lt;T&gt;\n\n\n截短\n\n\nmap\n中间\nStream&lt;R&gt;\nFunction&lt;T, R&gt;\nT -&gt; R\n映射\n\n\nflatMap\n中间\nStream&lt;R&gt;\nFunction&lt;T, Stream&lt;R&gt;&gt;\nT -&gt; Stream&lt;R&gt;\n展平\n\n\nsorted\n中间\nStream&lt;T&gt;\nComparator&lt;T&gt;\n(T, T) -&gt; int\n排序\n\n\npeek\n中间\nStream&lt;T&gt;\nConsumer&lt;T&gt;\nT -&gt; void\n消费流中的每个元素，主要用于调试\n\n\nanyMatch\n终端\nboolean\nPredicate&lt;T&gt;\nT -&gt; boolean\n是否至少匹配一个元素\n\n\nnoneMatch\n终端\nboolean\nPredicate&lt;T&gt;\nT -&gt; boolean\n是否匹配所有元素\n\n\nallMatch\n终端\nboolean\nPredicate&lt;T&gt;\nT -&gt; boolean\n是否没有任何元素匹配\n\n\nfindAny\n终端\nOptional&lt;T&gt;\n\n\n查找所有元素\n\n\nfindFirst\n终端\nOptional&lt;T&gt;\n\n\n查找第一个元素\n\n\nforeach\n终端\nvoid\nConsumer&lt;T&gt;\nT -&gt; void\n消费流中的每个元素并对其应用Lambda。这一操作返回void\n\n\ncollect\n终端\nR\nT -&gt; void\n\n把流归约成一个集合，比如List、Map 甚至是Integer\n\n\nreduce\n终端\nOptional&lt;T&gt;\nBinaryOperator&lt;T&gt;\n(T, T) -&gt; T\n归约\n\n\ncount\n终端\nlong\n\n\n查找第一个元素\n\n\n\n\n实际场景筛选和切片\nfilter: 根据传入的Predicate函数式接口, 返回一个包括所有符合条件元素的流\ndistinct: 返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流\nskip: 返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流\nlimit: 该方法会返回一个不超过给定长度的流。如果流是有序的,则最多返回前n个元素\n\nList&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 1, 3, 3, 2, 4, 6, 8); \nnumbers.stream() \n .filter(i -&gt; i % 2 &#x3D;&#x3D; 0) &#x2F;&#x2F; 过滤出偶数\n .distinct()              &#x2F;&#x2F; 相同的数字删除\n .skip(1)                 &#x2F;&#x2F; 跳过第一个元素\n .limit(2)                &#x2F;&#x2F; 取出前两个数\n .forEach(System.out::println); &#x2F;&#x2F; 4, 6  \n映射和展平\nmap: 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素\nflatMap: 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素\n\nList&lt;String&gt; words &#x3D; Arrays.asList(&quot;Hello&quot;,&quot;World&quot;);\nList&lt;String&gt; uniqueCharacters &#x3D; words.stream()\n        .map(w -&gt; w.split(&quot;&quot;))    &#x2F;&#x2F; 映射成一组字符数组\n        .flatMap(Arrays::stream)  &#x2F;&#x2F; 数组展平成一个数组\n        .distinct()               &#x2F;&#x2F; 字符去重\n        .collect(Collectors.toList());\n\n查找和匹配\nanyMatch: 流中是否有一个元素能匹配给定的条件\nnonneMatch: 流中是否没有一个元素能匹配给定的条件 \nfindAny: 方法将返回当前流中的任意元素\nfindFirst: 方法将返回当前流中的第一个元素\n\n&#x2F;&#x2F; anyMatch\nif(menu.stream().anyMatch(Dish::isVegetarian))&#123; \n    System.out.println(&quot;The menu is (somewhat) vegetarian friendly!!&quot;); \n&#125;\n\n&#x2F;&#x2F; nonneMatch\nboolean isHealthy &#x3D; menu.stream() \n    .noneMatch(d -&gt; d.getCalories() &gt;&#x3D; 1000);\n\n&#x2F;&#x2F; findAny \nOptional&lt;Dish&gt; dish &#x3D; menu.stream() \n    .filter(Dish::isVegetarian) \n    .findAny(); \n\n&#x2F;&#x2F; findFirst\nList&lt;Integer&gt; someNumbers &#x3D; Arrays.asList(1, 2, 3, 4, 5); \nOptional&lt;Integer&gt; firstSquareDivisibleByThree &#x3D; someNumbers.stream() \n    .map(x -&gt; x * x) \n    .filter(x -&gt; x % 3 &#x3D;&#x3D; 0) \n    .findFirst(); &#x2F;&#x2F; 9 \n归约和汇总\nreduce: reduce 操作可以实现从一组值中生成一个值\nmax: 获取最大值\nmin: 获取最小值\ncount: 获取总数\nCollectors.joining: 字符串合并  \n\nList&lt;Integer&gt; nums &#x3D; Arrays.asList(1,4,5,6,78);\n\n&#x2F;&#x2F; max\nInteger max &#x3D; nums.stream().max(Integer::compare).get(); &#x2F;&#x2F; 78\n\n&#x2F;&#x2F; min\nInteger min &#x3D; nums.stream().min(Integer::compare).get(); &#x2F;&#x2F; 1\n\n&#x2F;&#x2F; count\nLong count &#x3D; nums.stream().count(); &#x2F;&#x2F; 5\n\n&#x2F;&#x2F; reduce 求和\nInteger sum &#x3D; nums.stream().reduce(Integer::sum).get(); &#x2F;&#x2F; 94\n\nList&lt;String&gt; names &#x3D; Arrays.asList(&quot;Zebe&quot;, &quot;Hebe&quot;, &quot;Mary&quot;, &quot;July&quot;, &quot;David&quot;);\n\n&#x2F;&#x2F; 字符串合并\n&#x2F;&#x2F; 拼接成 [x, y, z] 形式\nString result1 &#x3D; names.stream().collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));\n&#x2F;&#x2F; 拼接成 x, y, z 形式\nString result2 &#x3D; names.stream().collect(Collectors.joining(&quot;,&quot;));\n&#x2F;&#x2F; 拼接成 xyz 形式\nString result3 &#x3D; names.stream().collect(Collectors.joining());\n分组和分区\nCollectors.groupingBy: 对数据按一定规则分组\nCollectors.partitioningBy: 分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数\n\nList&lt;Student&gt; stuList &#x3D; new ArrayList&lt;Student&gt;();\nStudent stu1 &#x3D; new Student(&quot;10001&quot;, &quot;孙权&quot;, &quot;1000101&quot;, 16, &#39;男&#39;);\nStudent stu2 &#x3D; new Student(&quot;10001&quot;, &quot;曹操&quot;, &quot;1000102&quot;, 16, &#39;男&#39;);\nStudent stu3 &#x3D; new Student(&quot;10002&quot;, &quot;刘备&quot;, &quot;1000201&quot;, 16, &#39;男&#39;);\nStudent stu4 &#x3D; new Student(&quot;10002&quot;, &quot;大乔&quot;, &quot;1000202&quot;, 16, &#39;女&#39;);\nStudent stu5 &#x3D; new Student(&quot;10002&quot;, &quot;小乔&quot;, &quot;1000203&quot;, 16, &#39;女&#39;);\nStudent stu6 &#x3D; new Student(&quot;10003&quot;, &quot;诸葛亮&quot;, &quot;1000301&quot;, 16, &#39;男&#39;);\n\n&#x2F;&#x2F; 按班级分组\nMap&lt;String, List&lt;Student&gt;&gt; collect &#x3D; stuList.stream()\n    .collect(Collectors.groupingBy(Student::getClassId)); &#x2F;&#x2F; &#123;&quot;10001&quot;:[], ...&#125;\n&#x2F;&#x2F; 或者使用Collectors.toMap按班级分组\nMap&lt;String, List&lt;Student&gt;&gt; collect1 &#x3D; stuList.stream()\n        .collect(Collectors.toMap(Student::getClassId,\n                stu -&gt; new ArrayList&lt;Student&gt;()&#123;&#123;add(stu);&#125;&#125;,\n                (a,b) -&gt; &#123;a.addAll(b);return a;&#125;));       &#x2F;&#x2F; &#123;&quot;10001&quot;:[], ...&#125;\n&#x2F;&#x2F; 按性别分组\nMap&lt;Boolean, List&lt;Student&gt;&gt; collect2 &#x3D; stuList.stream()\n    .collect(Collectors.partitioningBy(stu -&gt; \n    Objects.equals(&#39;男stu.getSex())));                    &#x2F;&#x2F; &#123;&quot;false&quot;:[], &quot;true&quot;: []&#125;\n\n收集器收集器非常有用，因为用它可以简洁而灵活地定义collect用来生成结果集合的标准。更具体地说，对流调用collect方法将对流中的元素触发一个归约操作（由Collector来参数化）。例如上述的Collectors.groupingBy、Collectors.partitioningBy\n常用Collectors类的静态工厂方法\n\n\n\n工厂方法\n返回类型\n用于\n\n\n\n\ntoList\nList&lt;T&gt;\n把流中所有项目收集到一个 List\n\n\n使用示例: List&lt;Dish&gt; dishes = menuStream.collect(toList());\n\n\ntoSet\nSet&lt;T&gt;\n把流中所有项目收集到一个 Set，删除重复项\n\n\n使用示例: ：Set&lt;Dish&gt; dishes = menuStream.collect(toSet());\n\n\ntoCollection\nCollection&lt;T&gt;\n把流中所有项目收集到给定的供应源创建的集合\n\n\n使用示例: java Collection&lt;Dish&gt; dishes = menuStream.collect(toCollection(), ArrayList::new);\n\n\ncounting\nLong\n计算流中元素的个数\n\n\n使用示例: long howManyDishes = menuStream.collect(counting());\n\n\nsummingInt\nInteger\n对流中项目的一个整数属性求和\n\n\n使用示例: int totalCalories = menuStream.collect(summingInt(Dish::getCalories));\n\n\naveragingInt\nDouble\n计算流中项目 Integer 属性的平均值\n\n\n使用示例: double avgCalories = menuStream.collect(averagingInt(Dish::getCalories));\n\n\nsummarizingInt\nIntSummaryStatistics\n收集关于流中项目 Integer 属性的统计值，例如最大、最小、总和与平均值\n\n\n使用示例: IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories));\n\n\njoining\nString\n连接对流中每个项目调用 toString 方法所生成的字符串\n\n\n使用示例: String shortMenu = menuStream.map(Dish::getName).collect(joining(&quot;, &quot;));\n\n\nmaxBy\nOptional&lt;T&gt;\n一个包裹了流中按照给定比较器选出的最大元素的 Optional，或如果流为空则为 Optional.empty()\n\n\n使用示例: Optional&lt;Dish&gt; fattest = menuStream.collect(maxBy(comparingInt(Dish::getCalories)));\n\n\nminBy\nOptional&lt;T&gt;\n一个包裹了流中按照给定比较器选出的最小元素的 Optional，或如果流为空则为 Optional.empty()\n\n\n使用示例: Optional&lt;Dish&gt; lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories)));\n\n\nreducing\n归约操作产生的类型\n从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值\n\n\n使用示例: int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));\n\n\ncollectingAndThen\n转换函数返回的类型\n包裹另一个收集器，对其结果应用转换函数\n\n\n使用示例: int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size));\n\n\ngroupingBy\nMap&lt;K, List&lt;T&gt;&gt;\n根据项目的一个属性的值对流中的项目作问组，并将属性值作为结果 Map 的键\n\n\n使用示例: Map&lt;Dish.Type,List&lt;Dish&gt;&gt; dishesByType = menuStream.collect(groupingBy(Dish::getType));\n\n\npartitioningBy\nMap&lt;Boolean,List&lt;T&gt;&gt;\n根据对流中每个项目应用谓词的结果来对项目进行分区\n\n\n使用示例: Map&lt;Boolean,List&lt;Dish&gt;&gt; vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarian))\n\n\n\n\n","slug":"Java Stream 流式编程","date":"2022-06-06T07:30:06.000Z","categories_index":"java,Stream,流式编程","tags_index":"java,Stream","author_index":"如峰"},{"id":"2b987db277ec8f53b5baaa150ea429a6","title":"Java函数式编程","content":"引言什么是函数式编程，即可以把方法当做参数或者返回值传递或引用。在JavaScript中函数式编程已经很常见，但是Java Function是不能作为参数引用，为此Java 8中提出了三个概念\n\n\n\n\n\n\n\n\n\n\nLambda 表达式，也可以称为闭包，但我更愿意称为定义函数的简写表达式\n方法引用，可以直接引用已有Java类或对象（实例）的方法或构造器\n函数式接口，一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口\n\nLambda 表达式java8之前函数的引用方式\nArrays.sort(array, new Comparator&lt;String&gt;() {\n    public int compare(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n});\n上述写法非常繁琐，从java8开始，我们可以使用Lambda表达式写。可以看出Lambda表达式是函数定义的简写方式，不用声明匿名类，JVM会自己帮我们做。\nArrays.sort(array, (String s1, String s2) -&gt; {\n    return s1.compareTo(s2);\n});\nLambda表达式的基本语法(parameters) -&gt;{ statements; }\nLambda的两个省略\n\n\n\n\n\n\n\n\n\n\n当箭头左边只有一个参数时,可省略()a =&gt; {return a + 1;}\n当箭头右边只有一句话时,可省略{}与return(a, b) =&gt; a + b;\n\n变量作用域\nLambda表达式只能引用标记了final的外层局部变量，这就是说不能在Lambda内部修改定义在域外的局部变量，否则会编译错误\nLambda表达式的局部变量可以不用声明为final，但是必须不可被后面的代码修改(即隐性的具有final的语义)\n在Lambda表达式当中不允许声明一个与局部变量同名的参数或者局部变量。\n\n例如：String first = \"\";  \nComparator &lt; String &gt; comparator = (first, second) -&gt; \n\tInteger.compare(first.length(), second.length()); // 编译会出错\nint num = 1;  \nConverter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));\ns.convert(2);\nnum = 5;  \n// 报错信息：Local variable num defined in an enclosing scope must be final or effectively final\n方法引用方法引用通过方法的名字来指向一个方法，可以使语音的构造更加紧凑，减少冗余代码，方法引用使用一对冒号。对于Arrays.sort方法,第二个参数Comparator是一个单方法接口，除了可以传入Lambda表达式，我们还可以直接传入符合要求的方法引Arrays.sort(array, String::compareTo);\n方法引用的基本语法构造器的引用语法： Class::newfinal Car car = Car.create( Car::new );\nfinal List&lt; Car &gt; cars = Arrays.asList( car );\n静态方法的引用语法： Class::static_methodcars.forEach( Car::collide );\n特定类的任意对象的方法引用语法： Class::methodcars.forEach( Car::repair );\n特定对象的方法引用语法： instance::methodfinal Car police = Car.create( Car::new );\ncars.forEach( police::follow );\n函数式接口Lambda表达式、方法引用只是针对方法的简写与特殊方法引用的简写。那我们该如何将更加复杂的函数传递和引用呢？那如何先声明一个可被传递或者引用的函数呢？使用@FunctionalInterface注解创建一个函数式接口即可\n@FunctionalInterface\ninterface Functional {\n  String goodbye(String message);\n}\n函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。所以上面接口的实现方式可用Lambda表达式简写为\nFunctional fx = message -&gt; System.out.println(\"Hello \" + message);\nfx.goodbye(\"world!!!\");\n\\underbrace{message -> System.out.println(\"Hello \" + message)}_{函数} \\quad  \\underrightarrow{赋值} \\quad fx.goodbye并通过fx.goodbye(\"world!!!\")调用。这也就是必须有且仅有一个抽象方法否则并不知道赋值给哪一个方法。\n四大函数式接口我们在使用函数式接口时，并不需要总是创建一个函数式接口。因为JAVA8已经为我们提供了常用的函数式接口。|函数式接口名|方法名|作用|特征|示例||—|—|—|—|—||Supplier|get()  getAs类型()|生产者函数式接口|无参数  有返回值|Supplier  BooleanSupplier  IntSupplier  LongSupplier  DoubleSupplier ||Consumer|accept()|消费者函数式接口|单个参数  无返回值|Consumer  IntConsumer  LongConsumer  DoubleConsumer||Predicate|test()|断言函数式接口|2 参数  返回布尔型|Predicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate||Function|apply()  applyAs类型()|功能函数式接口|单个参数  有返回值|Function  IntFunction  LongFunction  DoubleFunction  ToIntFunction  ToLongFunction  ToDoubleFunction  IntToLongFunction  IntToDoubleFunction  LongToIntFunction  LongToDoubleFunction  DoubleToIntFunction  DoubleToLongFunction|\nsupplier\\生产者函数式接口,无参数，返回一个T类型结果。如果返回类型是基本类型可以使用BooleanSupplier、IntSupplier、LongSupplier、DoubleSupplier\n示例\nSupplier&lt;String&gt; supplier = String::new; \nSupplier&lt;Emp&gt; supplierEmp = Emp::new;\nEmp emp = supplierEmp.get();\nemp.setName(\"dd\");\n\nSystem.out.println(supplier.get()); // \"\"\nSystem.out.println(emp.getName());  // dd\nConsumer\\接受一个T类型输入参数并且无返回。如果T是基本类型可以使用IntConsumer、LongConsumer、DoubleConsumer,如果需要输入两个参数使用BiConsumer,如果有一个类型是Obj,一个类型是基本类型可以使用ObjIntConsumer、ObjLongConsumer、ObjDoubleConsumer\n示例\nEmp emp = new Emp();\nConsumer&lt;Emp&gt; nameConsumer = emp -&gt; System.out.println(emp.getName());  \nnameConsumer.accept(emp); // 打印学生名字\nPredicate\\接受一个T类型输入参数并且返回布尔值。如果T是基本类型可以使用IntPredicate、LongPredicate、DoublePredicate,如果需要输入两个参数使用BiPredicate。\n示例Predicate&lt;Integer&gt; predicate = t -&gt; t &gt; 5;\nSystem.out.println(predicate.test(6)); // true \nFunction接受一个T类型输入参数返回一个R类型参数。如果T是基本类型可以使用IntFunction、LongFunction、DoubleFunction,如果R是基本类型ToIntFunction、ToLongFunction、ToDoubleFunction,如果T和R都是基本类型可以使用IntToLongFunction、IntToDoubleFunction、LongToIntFunction、LongToDoubleFunction、DoubleToIntFunction、DoubleToLongFunction,如果需要传入两个参数可以使用BiFunction,要是BiFunction返回类型是基本类型可以使用ToIntBiFunction、ToLongBiFunction、ToDoubleBiFunction。\n示例Function&lt;Integer,Integer&gt; fuc = t -&gt; t - 1;\nSystem.out.println(fuc.apply(6)); // 5 \n其它函数式接口\n\n\n\n函数式接口名\n作用\n\n\n\n\nRunnable\n不返回结果的线程\n\n\nCallable\n返回结果的线程\n\n\nUnaryOperator\n表示对同一类型的两个操作数的操作，产生与操作数相同类型的结果。\n\n\nBinaryOperator\n表示对单个操作数产生与其操作数相同类型的结果的操作。\n\n\nComparator\n对同类型的两个参数作比较\n\n\n\n\n函数组合函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。\n\n\n\n\n组合方法\n作用\n支持接口\n\n\n\n\nandThen(argument)\n执行原操作,再执行参数操作\nFunction  BiFunction  Consumer  BiConsumer  IntConsumer  LongConsumer  DoubleConsumer  UnaryOperator  IntUnaryOperator  LongUnaryOperator  DoubleUnaryOperator  BinaryOperator\n\n\ncompose(argument)\n执行参数操作,再执行原操作\nFunction  UnaryOperator  IntUnaryOperator  LongUnaryOperator  DoubleUnaryOperator\n\n\nand(argument)\n原Predicate函数式接口和参数Predicate函数式接口的短路逻辑与\nPredicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate\n\n\nor(argument)\n原Predicate函数式接口和参数Predicate函数式接口的短路逻辑或\nPredicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate\n\n\nnegate()\n该Predicate函数式接口的逻辑非\nPredicate  BiPredicate  IntPredicate  LongPredicate  DoublePredicate\n\n\n\n\n下例使用了Function里的compose()和andThen()。代码示例：\n// functional/FunctionComposition.java\nimport java.util.function.*;\npublic class FunctionComposition {\n  static Function&lt;String, String&gt;\n    f1 = s -&gt; {\n      System.out.println(s);\n      return s.replace('A', '_');\n    },\n    f2 = s -&gt; s.substring(3),\n    f3 = s -&gt; s.toLowerCase(),\n    f4 = f1.compose(f2).andThen(f3);\n  public static void main(String[] args) {\n    System.out.println(\n      f4.apply(\"GO AFTER ALL AMBULANCES\"));\n  }\n}\n输出结果：\nAFTER ALL AMBULANCES\n_fter _ll _mbul_nces\n这里我们重点看正在创建的新函数f4。它调用apply()的方式与Function函数式接口几乎无异。f4组合后的新函数,compose(f2)表示f2的调用发生在f1之前,所以当f1获得字符串时，它已经被f2剥离了前三个字符。\n下例是Predicate的逻辑运算演示。代码示例：\n// functional/PredicateComposition.java\nimport java.util.function.*;\nimport java.util.stream.*;\npublic class PredicateComposition {\n  static Predicate&lt;String&gt;\n    p1 = s -&gt; s.contains(\"bar\"),\n    p2 = s -&gt; s.length() &lt; 5,\n    p3 = s -&gt; s.contains(\"foo\"),\n    p4 = p1.negate().and(p2).or(p3);\n  public static void main(String[] args) {\n    Stream.of(\"bar\", \"foobar\", \"foobaz\", \"fongopuckey\")\n      .filter(p4)\n      .forEach(System.out::println);\n  }\n}\n输出结果：\nfoobar\nfoobaz\np4是由p1、p2、p3组成,其判断逻辑是：如果字符串中不包含bar且长度小于5，或者它包含foo，则结果为true。正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了Java Stream。首先，我创建了一个字符串对象的流，然后将每个对象传递给filter()操作。filter()使用p4的谓词来过滤。最后我们使用forEach()将println方法引用应用在每个留存的对象上。\n柯里化和部分求值将一个多参数的函数，转换为一系列单参数函数。\n// functional/CurryingAndPartials.java\nimport java.util.function.*;\npublic class CurryingAndPartials {\n   // 未柯里化:\n   static String uncurried(String a, String b) {\n      return a + b;\n   }\n   public static void main(String[] args) {\n      // 柯里化的函数:\n      Function&lt;String, Function&lt;String, String&gt;&gt; sum =\n         a -&gt; b -&gt; a + b; // [1]\n      System.out.println(uncurried(\"Hi \", \"Ho\"));\n      Function&lt;String, String&gt;\n        hi = sum.apply(\"Hi \"); // [2]\n      System.out.println(hi.apply(\"Ho\"));\n      // 部分应用:\n      Function&lt;String, String&gt; sumHi =\n        sum.apply(\"Hup \");\n      System.out.println(sumHi.apply(\"Ho\"));\n      System.out.println(sumHi.apply(\"Hey\"));\n   }\n}\n输出结果：\nHi Ho\nHi Ho\nHup Ho\nHup Hey\n\n\n\n\n\n\n\n\n\n 这一连串的箭头很巧妙。注意，在函数接口声明中，第二个参数是另一个函数。 柯里化的目的是能够通过提供单个参数来创建一个新函数，所以现在有了一个”带参函数”和剩下的”自由函数”(free argument)。实际上，你从一个双参数函数开始，最后得到一个单参数函数。\n我们可以通过继续添加层级来柯里化一个三参数函数:\n// functional/Curry3Args.java\nimport java.util.function.*;\npublic class Curry3Args {\n   public static void main(String[] args) {\n      Function&lt;String,\n        Function&lt;String,\n          Function&lt;String, String&gt;&gt;&gt; sum =\n            a -&gt; b -&gt; c -&gt; a + b + c;\n      Function&lt;String,\n        Function&lt;String, String&gt;&gt; hi =\n          sum.apply(\"Hi \");\n      Function&lt;String, String&gt; ho =\n        hi.apply(\"Ho \");\n      System.out.println(ho.apply(\"Hup\"));\n   }\n}\n输出结果：\nHi Ho Hup\n对于每一级的箭头级联(Arrow-cascading),你都会在类型声明周围包裹另一个Function。处理基本类型和装箱时,请使用适当的函数式接口：\n// functional/CurriedIntAdd.java\nimport java.util.function.*;\npublic class CurriedIntAdd {\n  public static void main(String[] args) {\n    IntFunction&lt;IntUnaryOperator&gt;\n      curriedIntAdd = a -&gt; b -&gt; a + b;\n    IntUnaryOperator add4 = curriedIntAdd.apply(4);\n    System.out.println(add4.applyAsInt(5));\n      }\n}\n输出结果：\n9\n总结在绝大多数多数的程序编写中,Lambda表达式和方法引用并配合Java Stream编程的方式的应用较多，但是函数式接口和柯里化的应用较少。个人觉得一方便绝大多数的开发还是CRUD和数据的梳理，另一方面只有在涉及到架构时或者编写通用工具方法时才有可能使用到函数式接口和柯里化。开发者在使用函数式接口和柯里化时需要从面向对象的思考方式做出部分的转变，以适应函数式编程。而且Java已经有了这么多年的历史，即使不使用函数式接口和柯里化也有成熟的解决方式，而市面上也并未有统一、成熟、全面的关于函数式接口和柯里化在Java开发中的规范要求去替代过去的方式。\n","slug":"Java函数式编程","date":"2022-05-31T13:30:06.000Z","categories_index":"java,函数式编程","tags_index":"java,函数式编程","author_index":"如峰"},{"id":"6a8b4d4d5ad2121dc1df69e7c613a802","title":"Lombok的使用一进阶篇","content":"进阶注解解析@SuperBuilder(实验性功能)是一个帮助类生成复杂的构建器 API。将循允许我们使用以下的方式去实例化对象，但是对继承的类的属性不会忽略,但是超类也必须使用此注解。使用方式可参照@Builder\n@Jacksonized(实验性功能)此注解是@Builder和@SuperBuilder的附加注解,允许他们Jackson序列化/反序列化不被报错\n例如\n@Jacksonized @Builder\n@JsonIgnoreProperties(ignoreUnknown &#x3D; true)\npublic class JacksonExample &#123;\n\tprivate List&lt;Foo&gt; foos;\n&#125;\n@Accessors(实验性功能)使用此注解允许使用以下的链式方式调用方法,注解的fluent熟悉默认为false,设置为true时,则getter/setter方法，没有get/set前缀。User user &#x3D; new User().age(31).name(&quot;pollyduan&quot;);\n例如\nimport lombok.experimental.Accessors;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Accessors(fluent &#x3D; true)\npublic class AccessorsExample &#123;\n  @Getter @Setter\n  private int age &#x3D; 10;\n&#125;\n\nclass PrefixExample &#123;\n  @Accessors(prefix &#x3D; &quot;f&quot;) @Getter\n  private String fName &#x3D; &quot;Hello, World!&quot;;\n&#125;\n编译后的实体\npublic class AccessorsExample &#123;\n  private int age &#x3D; 10;\n  \n  public int age() &#123;\n    return this.age;\n  &#125;\n  \n  public AccessorsExample age(final int age) &#123;\n    this.age &#x3D; age;\n    return this;\n  &#125;\n&#125;\n\nclass PrefixExample &#123;\n  private String fName &#x3D; &quot;Hello, World!&quot;;\n  \n  public String getName() &#123;\n    return this.fName;\n  &#125;\n&#125;\nvar关键字var替换掉了原来的val。var关键字可以让我们在定义一个变量时候不需要提前指定它的类型，它的实际的类型将由初始化的表达式推断,var声明的变量是非final的,而val声明的变量是final的。若要使用var声明final\n例如\nvar example &#x3D; new ArrayList&lt;String&gt;();\nexample.add(&quot;welcome to hangge.com&quot;);","slug":"Lombok的使用—进阶篇","date":"2022-05-25T15:30:06.000Z","categories_index":"Lombok","tags_index":"Lombok","author_index":"如峰"},{"id":"ad1f662ab87a679b9b7a6abe69e2649c","title":"Lombok的使用一基础篇","content":"序言Lombok是一款 Java 开发插件，使得 Java 开发者可以通过其定义的一些注解来消除业务工程中冗长和繁琐的代码\n常用注解解析@Data@Data是一个快捷注解，包含@Getter,@Setter,@ToString,@EqualsAndHashCode and @RequiredArgsConstructor注解。当@Data设置于类上时，将自动生成Getter、Setter、ToString、Equals、HashCode方法和默认构造器。\n例如\nimport lombok.Data;\n\n@Data\npublic class DataExample &#123;\n    private String name;\n&#125;\n编译后的实体类\npublic class DataExample &#123;\n    public String name;\n\n    public DataExample() &#123;\n    &#125;\n\n    public String getName() &#123;\n        return this.name;\n    &#125;\n\n    public void setName(final String name) &#123;\n        this.name &#x3D; name;\n    &#125;\n\n    public boolean equals(final Object o) &#123;\n        if (o &#x3D;&#x3D; this) &#123;\n            return true;\n        &#125; else if (!(o instanceof DataExample)) &#123;\n            return false;\n        &#125; else &#123;\n            DataExample other &#x3D; (DataExample)o;\n            if (!other.canEqual(this)) &#123;\n                return false;\n            &#125; else &#123;\n                Object this$name &#x3D; this.getName();\n                Object other$name &#x3D; other.getName();\n                if (this$name &#x3D;&#x3D; null) &#123;\n                    if (other$name !&#x3D; null) &#123;\n                        return false;\n                    &#125;\n                &#125; else if (!this$name.equals(other$name)) &#123;\n                    return false;\n                &#125;\n\n                return true;\n            &#125;\n        &#125;\n    &#125;\n\n    protected boolean canEqual(final Object other) &#123;\n        return other instanceof DataExample;\n    &#125;\n\n    public int hashCode() &#123;\n        int PRIME &#x3D; true;\n        int result &#x3D; 1;\n        Object $name &#x3D; this.getName();\n        int result &#x3D; result * 59 + ($name &#x3D;&#x3D; null ? 43 : $name.hashCode());\n        return result;\n    &#125;\n\n    public String toString() &#123;\n        return &quot;DataExample(name&#x3D;&quot; + this.getName() + &quot;)&quot;;\n    &#125;\n&#125;\n\n@Getter and @Setter当为某一字段设置@Getter、@Setter注解时将自动生成此字段的Getter、Setter方法。当为某实体类设置@Getter、@Setter注解时，相当于为类中所有非静态字段设置@Getter、@Setter注解。\n例如\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class GetterSetterExample &#123;\n    private int age ;\n&#125;\n编译后的实体类\npublic class GetterSetterExample &#123;\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n@NoArgsConstructor、@RequiredArgsConstructor、@AllArgsConstructor构造器注解@NoArgsConstructor 将生成一个没有参数的构造函数，如果有final字段需使用@NoArgsConstructor(force = true)初始化@AllArgsConstructor 为类中的每个字段生成一个带有 1 个参数的构造函数。标注@NonNull参数会进行空检查。@RequiredArgsConstructor 生成构造包含所有必须字段的参数，包括含@NotNull注解的字段并做空检查，和final修饰且未初始化的字段。\n例如\n\nimport lombok.AccessLevel;\nimport lombok.RequiredArgsConstructor;\nimport lombok.AllArgsConstructor;\nimport lombok.NonNull;\n\n@RequiredArgsConstructor(staticName &#x3D; &quot;of&quot;)\n@AllArgsConstructor(access &#x3D; AccessLevel.PROTECTED)\npublic class ConstructorExample&lt;T&gt; &#123;\n  private int x, y;\n  @NonNull private T description;\n  \n  @NoArgsConstructor\n  public static class NoArgsExample &#123;\n    @NonNull private String field;\n  &#125;\n&#125;\n编译后的实体类\npublic class ConstructorExample&lt;T&gt; &#123;\n  private int x, y;\n  @NonNull private T description;\n  \n  private ConstructorExample(T description) &#123;\n    if (description &#x3D;&#x3D; null) throw new NullPointerException(&quot;description&quot;);\n    this.description &#x3D; description;\n  &#125;\n  \n  public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) &#123;\n    return new ConstructorExample&lt;T&gt;(description);\n  &#125;\n  \n  @java.beans.ConstructorProperties(&#123;&quot;x&quot;, &quot;y&quot;, &quot;description&quot;&#125;)\n  protected ConstructorExample(int x, int y, T description) &#123;\n    if (description &#x3D;&#x3D; null) throw new NullPointerException(&quot;description&quot;);\n    this.x &#x3D; x;\n    this.y &#x3D; y;\n    this.description &#x3D; description;\n  &#125;\n  \n  public static class NoArgsExample &#123;\n    @NonNull private String field;\n    \n    public NoArgsExample() &#123;\n    &#125;\n  &#125;\n&#125;\n@EqualsAndHashCode任何类定义都可以用注释@EqualsAndHashCode来让Lombok生成equals(Object other)和hashCode()方法的实现。\n例如\nimport lombok.EqualsAndHashCode;\n\n@EqualsAndHashCode\npublic class EqualsAndHashCodeExample &#123;\n  private transient int transientVar &#x3D; 10;\n  private String name;\n  private double score;\n  @EqualsAndHashCode.Exclude private Shape shape &#x3D; new Square(5, 10);\n  private String[] tags;\n  @EqualsAndHashCode.Exclude private int id;\n  \n  public String getName() &#123;\n    return this.name;\n  &#125;\n  \n  @EqualsAndHashCode(callSuper&#x3D;true)\n  public static class Square extends Shape &#123;\n    private final int width, height;\n    \n    public Square(int width, int height) &#123;\n      this.width &#x3D; width;\n      this.height &#x3D; height;\n    &#125;\n  &#125;\n&#125;\n编译后的实体类\nimport java.util.Arrays;\n\npublic class EqualsAndHashCodeExample &#123;\n  private transient int transientVar &#x3D; 10;\n  private String name;\n  private double score;\n  private Shape shape &#x3D; new Square(5, 10);\n  private String[] tags;\n  private int id;\n  \n  public String getName() &#123;\n    return this.name;\n  &#125;\n  \n  @Override public boolean equals(Object o) &#123;\n    if (o &#x3D;&#x3D; this) return true;\n    if (!(o instanceof EqualsAndHashCodeExample)) return false;\n    EqualsAndHashCodeExample other &#x3D; (EqualsAndHashCodeExample) o;\n    if (!other.canEqual((Object)this)) return false;\n    if (this.getName() &#x3D;&#x3D; null ? other.getName() !&#x3D; null : !this.getName().equals(other.getName())) return false;\n    if (Double.compare(this.score, other.score) !&#x3D; 0) return false;\n    if (!Arrays.deepEquals(this.tags, other.tags)) return false;\n    return true;\n  &#125;\n  \n  @Override public int hashCode() &#123;\n    final int PRIME &#x3D; 59;\n    int result &#x3D; 1;\n    final long temp1 &#x3D; Double.doubleToLongBits(this.score);\n    result &#x3D; (result*PRIME) + (this.name &#x3D;&#x3D; null ? 43 : this.name.hashCode());\n    result &#x3D; (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32));\n    result &#x3D; (result*PRIME) + Arrays.deepHashCode(this.tags);\n    return result;\n  &#125;\n  \n  protected boolean canEqual(Object other) &#123;\n    return other instanceof EqualsAndHashCodeExample;\n  &#125;\n  \n  public static class Square extends Shape &#123;\n    private final int width, height;\n    \n    public Square(int width, int height) &#123;\n      this.width &#x3D; width;\n      this.height &#x3D; height;\n    &#125;\n    \n    @Override public boolean equals(Object o) &#123;\n      if (o &#x3D;&#x3D; this) return true;\n      if (!(o instanceof Square)) return false;\n      Square other &#x3D; (Square) o;\n      if (!other.canEqual((Object)this)) return false;\n      if (!super.equals(o)) return false;\n      if (this.width !&#x3D; other.width) return false;\n      if (this.height !&#x3D; other.height) return false;\n      return true;\n    &#125;\n    \n    @Override public int hashCode() &#123;\n      final int PRIME &#x3D; 59;\n      int result &#x3D; 1;\n      result &#x3D; (result*PRIME) + super.hashCode();\n      result &#x3D; (result*PRIME) + this.width;\n      result &#x3D; (result*PRIME) + this.height;\n      return result;\n    &#125;\n    \n    protected boolean canEqual(Object other) &#123;\n      return other instanceof Square;\n    &#125;\n  &#125;\n&#125;\n@NonNull您可以@NonNull在字段、方法、构造函数的参数上使用。这将导致Lombok为您生成一个空检查语句。\n例如\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something &#123;\n  private String name;\n  \n  public NonNullExample(@NonNull Person person) &#123;\n    super(&quot;Hello&quot;);\n    this.name &#x3D; person.getName();\n  &#125;\n&#125;\n编译后的实体类\nimport lombok.NonNull;\n\npublic class NonNullExample extends Something &#123;\n  private String name;\n  \n  public NonNullExample(@NonNull Person person) &#123;\n    super(&quot;Hello&quot;);\n    if (person &#x3D;&#x3D; null) &#123;\n      throw new NullPointerException(&quot;person is marked non-null but is null&quot;);\n    &#125;\n    this.name &#x3D; person.getName();\n  &#125;\n&#125;\n@LogLombok里关于@Log添加了多种变体，无论使用哪个，都将生成一个静态的final log字段，按照你使用的日志框架的通常规定的方式进行初始化，然后你可以使用它来编写日志语句。变体有@CommonsLog、@Flogger、@JBossLog、@Log、@Log4j、@Log4j2、@Slf4j、@XSlf4j、@CustomLog。\n例如\nimport lombok.extern.java.Log;\nimport lombok.extern.slf4j.Slf4j;\n\n@Log\npublic class LogExample &#123;\n  \n  public static void main(String... args) &#123;\n    log.severe(&quot;Something&#39;s wrong here&quot;);\n  &#125;\n&#125;\n\n@Slf4j\npublic class LogExampleOther &#123;\n  \n  public static void main(String... args) &#123;\n    log.error(&quot;Something else is wrong here&quot;);\n  &#125;\n&#125;\n\n@CommonsLog(topic&#x3D;&quot;CounterLog&quot;)\npublic class LogExampleCategory &#123;\n\n  public static void main(String... args) &#123;\n    log.error(&quot;Calling the &#39;CounterLog&#39; with a message&quot;);\n  &#125;\n&#125;\n编译后的实体类\npublic class LogExample &#123;\n  private static final java.util.logging.Logger log &#x3D; java.util.logging.Logger.getLogger(LogExample.class.getName());\n  \n  public static void main(String... args) &#123;\n    log.severe(&quot;Something&#39;s wrong here&quot;);\n  &#125;\n&#125;\n\npublic class LogExampleOther &#123;\n  private static final org.slf4j.Logger log &#x3D; org.slf4j.LoggerFactory.getLogger(LogExampleOther.class);\n  \n  public static void main(String... args) &#123;\n    log.error(&quot;Something else is wrong here&quot;);\n  &#125;\n&#125;\n\npublic class LogExampleCategory &#123;\n  private static final org.apache.commons.logging.Log log &#x3D; org.apache.commons.logging.LogFactory.getLog(&quot;CounterLog&quot;);\n\n  public static void main(String... args) &#123;\n    log.error(&quot;Calling the &#39;CounterLog&#39; with a message&quot;);\n  &#125;\n&#125;\n","slug":"Lombok的使用一基础篇","date":"2022-05-19T15:30:06.000Z","categories_index":"Lombok","tags_index":"Lombok","author_index":"如峰"},{"id":"f4f9a107b18653850d81e048925a42ea","title":"Lombok的使用一中级篇","content":"高级注解解析@Builder是一个帮助类生成复杂的构建器 API。将允许我们使用以下的方式去实例化对象，但是对继承的类的属性会忽略。Person.builder()\n   .name(&quot;Adam Savage&quot;)\n   .city(&quot;San Francisco&quot;)\n   .job(&quot;Mythbusters&quot;)\n   .job(&quot;Unchained Reaction&quot;)\n  .build();当你想为某一字段使用默认值时，使用@Builder.Default@Builder.Default \nprivate long created &#x3D; System.currentTimeMillis()当某个字段为集合类型时，使用@Singular@Singular \nprivate Set&lt;String&gt; occupations;例如\n\nimport lombok.Builder;\nimport lombok.Singular;\nimport java.util.Set;\n\n@Builder\npublic class BuilderExample &#123;\n  @Builder.Default private long created &#x3D; System.currentTimeMillis();\n  private String name;\n  private int age;\n  @Singular private Set&lt;String&gt; occupations;\n&#125;\n编译后的实体类\nimport java.util.Set;\n\npublic class BuilderExample &#123;\n  private long created;\n  private String name;\n  private int age;\n  private Set&lt;String&gt; occupations;\n  \n  BuilderExample(String name, int age, Set&lt;String&gt; occupations) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n    this.occupations &#x3D; occupations;\n  &#125;\n  \n  private static long $default$created() &#123;\n    return System.currentTimeMillis();\n  &#125;\n  \n  public static BuilderExampleBuilder builder() &#123;\n    return new BuilderExampleBuilder();\n  &#125;\n  \n  public static class BuilderExampleBuilder &#123;\n    private long created;\n    private boolean created$set;\n    private String name;\n    private int age;\n    private java.util.ArrayList&lt;String&gt; occupations;\n    \n    BuilderExampleBuilder() &#123;\n    &#125;\n    \n    public BuilderExampleBuilder created(long created) &#123;\n      this.created &#x3D; created;\n      this.created$set &#x3D; true;\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder name(String name) &#123;\n      this.name &#x3D; name;\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder age(int age) &#123;\n      this.age &#x3D; age;\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder occupation(String occupation) &#123;\n      if (this.occupations &#x3D;&#x3D; null) &#123;\n        this.occupations &#x3D; new java.util.ArrayList&lt;String&gt;();\n      &#125;\n      \n      this.occupations.add(occupation);\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder occupations(Collection&lt;? extends String&gt; occupations) &#123;\n      if (this.occupations &#x3D;&#x3D; null) &#123;\n        this.occupations &#x3D; new java.util.ArrayList&lt;String&gt;();\n      &#125;\n\n      this.occupations.addAll(occupations);\n      return this;\n    &#125;\n    \n    public BuilderExampleBuilder clearOccupations() &#123;\n      if (this.occupations !&#x3D; null) &#123;\n        this.occupations.clear();\n      &#125;\n      \n      return this;\n    &#125;\n\n    public BuilderExample build() &#123;\n      &#x2F;&#x2F; complicated switch statement to produce a compact properly sized immutable set omitted.\n      Set&lt;String&gt; occupations &#x3D; ...;\n      return new BuilderExample(created$set ? created : BuilderExample.$default$created(), name, age, occupations);\n    &#125;\n    \n    @java.lang.Override\n    public String toString() &#123;\n      return &quot;BuilderExample.BuilderExampleBuilder(created &#x3D; &quot; + this.created + &quot;, name &#x3D; &quot; + this.name + &quot;, age &#x3D; &quot; + this.age + &quot;, occupations &#x3D; &quot; + this.occupations + &quot;)&quot;;\n    &#125;\n  &#125;\n&#125;\n@SneakyThrows(慎用)可以用来偷偷抛出检查异常，而无需在方法的throws子句中实际声明它。\n例如import lombok.SneakyThrows;\n\npublic class SneakyThrowsExample implements Runnable &#123;\n  @SneakyThrows(UnsupportedEncodingException.class)\n  public String utf8ToString(byte[] bytes) &#123;\n    return new String(bytes, &quot;UTF-8&quot;);\n  &#125;\n  \n  @SneakyThrows\n  public void run() &#123;\n    throw new Throwable();\n  &#125;\n&#125;\n编译后的实体\nimport lombok.Lombok;\n\npublic class SneakyThrowsExample implements Runnable &#123;\n  public String utf8ToString(byte[] bytes) &#123;\n    try &#123;\n      return new String(bytes, &quot;UTF-8&quot;);\n    &#125; catch (UnsupportedEncodingException e) &#123;\n      throw Lombok.sneakyThrow(e);\n    &#125;\n  &#125;\n  \n  public void run() &#123;\n    try &#123;\n      throw new Throwable();\n    &#125; catch (Throwable t) &#123;\n      throw Lombok.sneakyThrow(t);\n    &#125;\n  &#125;\n&#125;\n\n@Synchronized(慎用)此注解是synchronized方法修饰符的一个更安全的变体。就像synchronized，注解只能用于静态和实例方法。它的操作类似于synchronized关键字，但它锁定不同的对象。\n例如\nimport lombok.Synchronized;\n\npublic class SynchronizedExample &#123;\n  private final Object readLock &#x3D; new Object();\n  \n  @Synchronized\n  public static void hello() &#123;\n    System.out.println(&quot;world&quot;);\n  &#125;\n  \n  @Synchronized\n  public int answerToLife() &#123;\n    return 42;\n  &#125;\n  \n  @Synchronized(&quot;readLock&quot;)\n  public void foo() &#123;\n    System.out.println(&quot;bar&quot;);\n  &#125;\n&#125;\n编译后的实体\npublic class SynchronizedExample &#123;\n  private static final Object $LOCK &#x3D; new Object[0];\n  private final Object $lock &#x3D; new Object[0];\n  private final Object readLock &#x3D; new Object();\n  \n  public static void hello() &#123;\n    synchronized($LOCK) &#123;\n      System.out.println(&quot;world&quot;);\n    &#125;\n  &#125;\n  \n  public int answerToLife() &#123;\n    synchronized($lock) &#123;\n      return 42;\n    &#125;\n  &#125;\n  \n  public void foo() &#123;\n    synchronized(readLock) &#123;\n      System.out.println(&quot;bar&quot;);\n    &#125;\n  &#125;\n&#125;\n@With当你需要克隆对象，修改一个值而保留其他值不变时，则使用此注解。\n例如\nimport lombok.AccessLevel;\nimport lombok.NonNull;\nimport lombok.With;\n\npublic class WithExample &#123;\n  @With(AccessLevel.PROTECTED) @NonNull private final String name;\n  @With private final int age;\n  \n  public WithExample(@NonNull String name, int age) &#123;\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n  &#125;\n&#125;\n编译后的实体类\nimport lombok.NonNull;\n\npublic class WithExample &#123;\n  private @NonNull final String name;\n  private final int age;\n\n  public WithExample(String name, int age) &#123;\n    if (name &#x3D;&#x3D; null) throw new NullPointerException();\n    this.name &#x3D; name;\n    this.age &#x3D; age;\n  &#125;\n\n  protected WithExample withName(@NonNull String name) &#123;\n    if (name &#x3D;&#x3D; null) throw new java.lang.NullPointerException(&quot;name&quot;);\n    return this.name &#x3D;&#x3D; name ? this : new WithExample(name, age);\n  &#125;\n\n  public WithExample withAge(int age) &#123;\n    return this.age &#x3D;&#x3D; age ? this : new WithExample(name, age);\n  &#125;\n&#125;\n@Getter(lazy=true)标注字段为懒加载字段，懒加载字段在创建对象时不会进行初始化，而是在第一次访问的时候才会初始化，后面再次访问也不会重复初始化。\n例如\nimport lombok.Getter;\n\npublic class GetterLazyExample &#123;\n  @Getter(lazy&#x3D;true) private final double[] cached &#x3D; expensive();\n  \n  private double[] expensive() &#123;\n    double[] result &#x3D; new double[1000000];\n    for (int i &#x3D; 0; i &lt; result.length; i++) &#123;\n      result[i] &#x3D; Math.asin(i);\n    &#125;\n    return result;\n  &#125;\n&#125;\n编译后的实体\npublic class GetterLazyExample &#123;\n  private final java.util.concurrent.AtomicReference&lt;java.lang.Object&gt; cached &#x3D; new java.util.concurrent.AtomicReference&lt;java.lang.Object&gt;();\n  \n  public double[] getCached() &#123;\n    java.lang.Object value &#x3D; this.cached.get();\n    if (value &#x3D;&#x3D; null) &#123;\n      synchronized(this.cached) &#123;\n        value &#x3D; this.cached.get();\n        if (value &#x3D;&#x3D; null) &#123;\n          final double[] actualValue &#x3D; expensive();\n          value &#x3D; actualValue &#x3D;&#x3D; null ? this.cached : actualValue;\n          this.cached.set(value);\n        &#125;\n      &#125;\n    &#125;\n    return (double[])(value &#x3D;&#x3D; this.cached ? null : value);\n  &#125;\n  \n  private double[] expensive() &#123;\n    double[] result &#x3D; new double[1000000];\n    for (int i &#x3D; 0; i &lt; result.length; i++) &#123;\n      result[i] &#x3D; Math.asin(i);\n    &#125;\n    return result;\n  &#125;\n&#125;\n@Cleanup主要用来修饰 IO 流相关类, 会在 finally 代码块中对该资源进行 close();\n例如\nimport lombok.Cleanup;\nimport java.io.*;\n\npublic class CleanupExample &#123;\n  public static void main(String[] args) throws IOException &#123;\n    @Cleanup InputStream in &#x3D; new FileInputStream(args[0]);\n    @Cleanup OutputStream out &#x3D; new FileOutputStream(args[1]);\n    byte[] b &#x3D; new byte[10000];\n    while (true) &#123;\n      int r &#x3D; in.read(b);\n      if (r &#x3D;&#x3D; -1) break;\n      out.write(b, 0, r);\n    &#125;\n  &#125;\n&#125;\n编译后的实体\nimport java.io.*;\n\npublic class CleanupExample &#123;\n  public static void main(String[] args) throws IOException &#123;\n    InputStream in &#x3D; new FileInputStream(args[0]);\n    try &#123;\n      OutputStream out &#x3D; new FileOutputStream(args[1]);\n      try &#123;\n        byte[] b &#x3D; new byte[10000];\n        while (true) &#123;\n          int r &#x3D; in.read(b);\n          if (r &#x3D;&#x3D; -1) break;\n          out.write(b, 0, r);\n        &#125;\n      &#125; finally &#123;\n        if (out !&#x3D; null) &#123;\n          out.close();\n        &#125;\n      &#125;\n    &#125; finally &#123;\n      if (in !&#x3D; null) &#123;\n        in.close();\n      &#125;\n    &#125;\n  &#125;\n&#125;\n","slug":"Lombok的使用一中级篇","date":"2022-05-19T15:30:06.000Z","categories_index":"Lombok","tags_index":"Lombok","author_index":"如峰"},{"id":"91e0f6f330b5dca608acfed732198bf6","title":"JavaScript代码技巧","content":"变量的声明var、const、let的区别\n\n\n\n表头\nvar\nlet\nconst\n\n\n\n\n定义常量\n\n\n√\n\n\n定义变量\n√\n√\n\n\n\n可被释放\n√\n√\n√\n\n\n可被提升\n√\n\n\n\n\n重复定义检查\n\n√\n√\n\n\n可用于块级作用域\n\n√\n√\n\n\n\n\n多行变量声明的优化let name &#x3D; 1;  &#x2F;&#x2F; 名称\nlet age &#x3D; 2;   &#x2F;&#x2F; 年龄\nlet classes &#x3D; 3; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\n\n&#x2F;&#x2F; 名称 年龄 班级\nlet [name, age, classes] &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 特别多的变量,当需要换行时的格式\nlet [name, age, classes]\n    &#x3D; [1, 2, 3];\n\n&#x2F;&#x2F; 此方式默认值的设置,myClasses默认值设置3\nlet [name, age, myClasses]\n    &#x3D; [1, 2, class || 3];\n\n&#x2F;&#x2F; 声明三个都是undefined的变量\nlet [name, age, myClasses] &#x3D; [];\n&#x2F;&#x2F; 声明三个都是空的变量 \nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(4).join(&#39;0&#39;).split(&#39;&#39;);\n\n&#x2F;&#x2F; 声明三个都是0的变量\nlet [name, age, myClasses] &#x3D; new Array(3).fill(0);\nlet [name, age, myClasses] &#x3D; Array.from(&#123;length: 3&#125;).map(()&#x3D;&gt; 0)\n\n数组取值的优化let arr &#x3D; [1, 2, 3];\nlet arr1 &#x3D; arr[0];\nlet arr2 &#x3D; arr[1];\nlet arr3 &#x3D; arr[2];\n\n&#x2F;&#x2F; 优化后\nlet arr &#x3D; [1, 2, 3];\nlet [arr1, arr2, arr3] &#x3D; arr;\n\n对象取值的优化let student &#x3D; &#123;name:1, age:2, classes:3&#125;;\nlet name &#x3D; student.name;   &#x2F;&#x2F; 名称\nlet age &#x3D; student.age;     &#x2F;&#x2F; 年龄\nlet classes &#x3D; student.classes; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet &#123;name : name, age : age, classes : classes&#125; &#x3D; student;\n&#x2F;&#x2F; 变量与属性名不相同 (key : value) key:JSON对象的属性名 value:变量名\nlet &#123;name : myName, age : myAge, classes : myClasses&#125; &#x3D; student;\n&#x2F;&#x2F; 此种对象的默认值设置仅在等于undefined的时候触发Myclasses &#x3D; 0\nlet &#123;name : myName, age : myAge, classes : myClasses &#x3D; 0&#125; &#x3D; student;\n \nlet &#123;name , age , classes&#125; &#x3D; student;\n\n逻辑与 &amp;&amp; 、逻辑或 || 的使用在使用之前我们要理解逻辑与和逻辑或的重要特性,短路.逻辑与: 当前面为假时,则直接返回假,否则返回后面的结果逻辑或: 当前面为真时,则直接返回真,否则返回后面的结果\n默认值的优化&#x2F;&#x2F; myName默认值的优化\nlet name &#x3D; 1;\nif (name) &#123;\n    let myName &#x3D; name;\n&#125; else &#123;\n    let myName &#x3D; 2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet name &#x3D; 1;\nlet myName &#x3D; name || 2;\n&#x2F;&#x2F; 扩展:我们在函数调用时设置默认值\ngetName(myName || name);\n\n单行if语句的优化&#x2F;&#x2F; 单行if语句的优化\nif(name)&#123; console.log(name)&#125;\n\n&#x2F;&#x2F; 优化后\nname &amp;&amp; console.log(name);\n\n取非空对象值的优化&#x2F;&#x2F; 取非空JSON值的优化\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\n\n&#x2F;&#x2F; student与student在代码逻辑中,只有一个有值,且我们要取出这个name,优先取student\nlet name &#x3D; null;\nif (student) &#123;\n    name &#x3D; student.name;\n&#125; else if(student1) &#123;\n    name &#x3D; student1.name;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet student &#x3D; null;\nlet student1 &#x3D; &#123;name : 1&#125;;\nlet name &#x3D; (student || student1)[&#39;name&#39;];\n&#x2F;&#x2F; 或者\nlet name &#x3D; (student || student1).name;\n\nJSON的使用JSON声明的优化let student &#x3D; &#123;&#125;;\nlet classes &#x3D; 2;\nstudent.name &#x3D; 1;\nstudent.classes &#x3D; classes || 3;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; 2;\nlet student &#x3D; &#123;\n    name : 1,\n    classes : classes || 3,\n&#125;;\n\nJSON取值的优化let student &#x3D; &#123;\n    name : 1,\n    classes1 : null,\n    classes2 : 3,\n&#125;;\n&#x2F;&#x2F; 当classes1为空时取classes2\nlet classes &#x3D; null;\nif (student.classes1) &#123;\n    classes &#x3D; student.classes1;\n&#125; else &#123;\n    classes &#x3D; student.classes2;\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet classes &#x3D; student.classes1 || student.classes2;\nlet classes &#x3D; student[&quot;classes1&quot;] || student[&#39;classes2&quot;];\n\n条件运算符的使用if else 语句的优化let method &#x3D; request.method;\nif (method &#x3D;&#x3D; &#39;GET&#39;) &#123;\n    let name &#x3D; request.getValue(&quot;name&quot;);\n&#125; else &#123;\n    let name &#x3D; request.getValue(&quot;custpage_name&quot;);\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet method &#x3D; request.method;\nlet name &#x3D; request.getValue(method &#x3D;&#x3D; &#39;GET&#39; ? &quot;name&quot; : &quot;custpage_name&quot;);\nlet name &#x3D; method &#x3D;&#x3D; &#39;GET&#39; ? request.getValue(&quot;name&quot;) : request.getValue(&quot;custpage_name&quot;);\n\n方法调用的优化let isUp &#x3D; false;\nif (isUp)&#123;\n    up();\n&#125; else &#123;\n    down();\n&#125;\n\n&#x2F;&#x2F; 优化后\nlet isUp &#x3D; false;\nisUp ? up() : down();\n&#x2F;&#x2F; 或者在函数的返回值使用条件运算符\nfunction jump(isUp)&#123;\n    return isUp ? up() : down();\n&#125;\n其它链式调用var form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;);\nhtmlHeader.updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;);\nhtmlHeader.updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;);\nhtmlHeader.defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n\n&#x2F;&#x2F; 链式调用\nvar form &#x3D; serverWidget.createForm(&#123;\n\t\ttitle: &#39;Thank you for your interest in Wolfe Electronics&#39;,\n\t\thideNavBar: true\n\t&#125;);\nvar htmlHeader &#x3D; form.addField(&#123;\n\t\tid: &#39;custpage_header&#39;,\n\t\ttype: serverWidget.FieldType.INLINEHTML,\n\t\tlabel: &#39; &#39;\n\t&#125;).updateLayoutType(&#123;\n\t\tlayoutType: serverWidget.FieldLayoutType.OUTSIDEABOVE\n\t&#125;).updateBreakType(&#123;\n\t\tbreakType: serverWidget.FieldBreakType.STARTROW\n\t&#125;).defaultValue &#x3D; &#39;&lt;p style&#x3D;\\&#39;font-size:20px\\&#39;&gt;We pride ourselves on providing the best&#39; + &#39; services and customer satisfaction. Please take a moment to fill out our survey.&lt;&#x2F;p&gt;&lt;br&gt;&lt;br&gt;&#39;;\n字符串拼接let n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\n\nlet string &#x3D; n + &quot;-&quot; + b + &quot;-&quot; + s + &quot;-&quot; + y;\nlet string2 &#x3D; n + b + s + y;\n\n&#x2F;&#x2F; 优化后\nlet n &#x3D; &#39;1&#39;;\nlet b &#x3D; &#39;2&#39;;\nlet s &#x3D; &#39;3&#39;;\nlet y &#x3D; &#39;4&#39;;\nlet string &#x3D; [n, b ,s,y].join(&quot;-&quot;);\nlet string2 &#x3D; n.concat(b, s, y);\n\n&#x2F;&#x2F; 字符串拼接其他方式\nlet string &#x3D; &quot;a-b-c-y&quot;;\nstring &#x3D; string.replace(&quot;a&quot;,a).replace(&quot;b&quot;,b).replace(&quot;b&quot;,b).replace(&quot;y&quot;,y);\n包含判断let a &#x3D; 1;\nif(a &#x3D;&#x3D; 1 || a &#x3D;&#x3D; 2 || a &#x3D;&#x3D; 3)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n    \n&#x2F;&#x2F; 优化\nif([1, 2, 3].indexof(a) &gt;&#x3D; 0)&#123; \n    &#x2F;&#x2F; doSomething\n&#125;\n\n数组的简写方式let a &#x3D; new Array();\n\n&#x2F;&#x2F; 简写\nlet a &#x3D; [];\n箭头函数箭头函数就是函数的简写方式function doSomething(a, b)&#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; 以下仅仅@NApiVersion 2.0以上可以使用\n&#x2F;&#x2F; 简写\nlet doSomething &#x3D; (a, b) &#x3D;&gt; &#123;return a + b;&#125;;\n\n&#x2F;&#x2F; 箭头函数的两个省略\n&#x2F;&#x2F; 1.当箭头左边只有一个参数时,可省略()\na &#x3D;&gt; &#123;return a + 1;&#125;;\n&#x2F;&#x2F; 2.当箭头右边只有一句话时,可省略&#123;&#125;与return\n(a, b) &#x3D;&gt; a + b;\n对象的keys、values的使用let student &#x3D; &#123;\n    name : 1,\n    classes : 3,\n&#125;;\n\n&#x2F;&#x2F; 获取对象的Keys\nObject.keys(student);   &#x2F;&#x2F; expected output: [&quot;name&quot;, &quot;classes&quot;]\n&#x2F;&#x2F; 获取对象的values\nObject.values(student); &#x2F;&#x2F; expected output: [1, 3]\n\n&#x2F;&#x2F; 判断对象是否具有该属性\nstudent.hasOwnProperty(&quot;classes&quot;);\nObject.keys(student).indexof(&quot;name&quot;) &gt;&#x3D; 0;\n\n数组的常用函数 &#x2F;&#x2F; filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 \nconst words &#x3D; [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];\nconst result &#x3D; words.filter(word &#x3D;&gt; word.length &gt; 6);\nconsole.log(result);             &#x2F;&#x2F; expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]\n\n&#x2F;&#x2F; find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。\nconst array1 &#x3D; [5, 12, 8, 130, 44];\nconst found &#x3D; array1.find(element &#x3D;&gt; element &gt; 10);\nconsole.log(found);              &#x2F;&#x2F; expected output: 12\n\n&#x2F;&#x2F; forEach() 方法对数组的每个元素执行一次给定的函数。\nconst array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\narray1.forEach(element &#x3D;&gt; console.log(element));\n\n&#x2F;&#x2F; includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。\nconst array1 &#x3D; [1, 2, 3];\nconsole.log(array1.includes(2));   &#x2F;&#x2F; expected output: true\nconst pets &#x3D; [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;];\nconsole.log(pets.includes(&#39;cat&#39;)); &#x2F;&#x2F; expected output: true\nconsole.log(pets.includes(&#39;at&#39;));  &#x2F;&#x2F; expected output: false\n\n&#x2F;&#x2F; map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\nconst array1 &#x3D; [1, 4, 9, 16];     &#x2F;&#x2F; pass a function to map\nconst map1 &#x3D; array1.map(x &#x3D;&gt; x * 2);\nconsole.log(map1);                &#x2F;&#x2F; expected output: Array [2, 8, 18, 32]\n\n&#x2F;&#x2F; reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\nconst array1 &#x3D; [1, 2, 3, 4];\nconst reducer &#x3D; (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue; \n&#x2F;&#x2F; 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer));                                       &#x2F;&#x2F; expected output: 10\n&#x2F;&#x2F; 5 + 1 + 2 + 3 + 4\nconsole.log(array1.reduce(reducer, 5));                                    &#x2F;&#x2F; expected output: 15\n这些方法是ES6以上可以使用,但是我们想在ES6以下运用这些方法时,只需按照网址:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array找到对应函数polyfill复制粘贴就能使用.\n字符串常用方法&#x2F;&#x2F; padEnd()  方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。\n&#39;abc&#39;.padEnd(10);          &#x2F;&#x2F; &quot;abc       &quot;\n&#39;abc&#39;.padEnd(10, &quot;foo&quot;);   &#x2F;&#x2F; &quot;abcfoofoof&quot;\n&#39;abc&#39;.padEnd(6, &quot;123456&quot;); &#x2F;&#x2F; &quot;abc123&quot;\n&#39;abc&#39;.padEnd(1);           &#x2F;&#x2F; &quot;abc&quot;\n\n&#x2F;&#x2F; padStart() 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。\n&#39;abc&#39;.padStart(10);         &#x2F;&#x2F; &quot;       abc&quot;\n&#39;abc&#39;.padStart(10, &quot;foo&quot;);  &#x2F;&#x2F; &quot;foofoofabc&quot;\n&#39;abc&#39;.padStart(6,&quot;123465&quot;); &#x2F;&#x2F; &quot;123abc&quot;\n&#39;abc&#39;.padStart(8, &quot;0&quot;);     &#x2F;&#x2F; &quot;00000abc&quot;\n&#39;abc&#39;.padStart(1);          &#x2F;&#x2F; &quot;abc&quot;\n这些方法注意事项同上.\n优化的注意事项在优化之前我们要理解为什么要优化代码,所有的优化都是为了代码的可读性,但在某些情况下以上的例子不优化可能比优化的可读性要好例如 \n&#x2F;&#x2F; 声明三个都是空的变量 \nlet name &#x3D; null;    &#x2F;&#x2F; 名称\nlet age &#x3D; null;     &#x2F;&#x2F; 年龄\nlet classes &#x3D; null; &#x2F;&#x2F; 班级\n\n&#x2F;&#x2F; 优化后\nlet [name, age, myClasses] &#x3D; new Array(4).join().split(&#39;,&#39;) || null;\n难道上面name, age, classes的声明方式比下面的优化语句,可读性差吗?并没有,但是当声明10个、20个、30个以上空的变量时,下面的优化语句就比上面的可读性强.当我们发现优化后并没有对可读性有提升时,就没必要优化.不过我们依然需要了解这些优化方式,以免我们需要增加代码可读性的时候,无从下手,或者不理解别人的代码.可读性不强的代码千千万万,优化的方式也多种多样,我们应当不放过自己可读性不强的代码,记住别人好的优化方式.各位还有别的案例或者优化方式,都可以自己更新这个文档,分享出来.\n网址的分享Javascript教程:https://wangdoc.com/javascript/index.htmlJS编程规范:https://github.com/airbnb/javascript/tree/es5-deprecated/es5ECMAScript6入门:https://es6.ruanyifeng.com/?search=%E7%AE%AD%E5%A4%B4&amp;x=0&amp;y=0JavaScript帮助文档:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_ObjectswebStorm激活码获取:http://idea.94goo.com/\n","slug":"JavaScript代码技巧","date":"2022-05-16T15:05:06.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"如峰"}]