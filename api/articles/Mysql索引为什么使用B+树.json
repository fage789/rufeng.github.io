{"title":"Mysql索引 - 为什么使用B+树","uid":"2c03d9b1a2276865a0e94d2f6eb59bcd","slug":"Mysql索引为什么使用B+树","date":"2022-06-13T08:30:06.000Z","updated":"2022-11-04T05:56:23.543Z","comments":true,"path":"api/articles/Mysql索引为什么使用B+树.json","keywords":null,"cover":[],"content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>通过分析哈希索引、平衡二叉树、B树、B+树来判断Mysql为什么使用B+树。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>其中文章中使用的<a href=\"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\">数据结构可视化地址</a>能够更好的帮助大家了解这四种索引方式。</p></blockquote>\n<h3 id=\"哈希树\"><a href=\"#哈希树\" class=\"headerlink\" title=\"哈希树\"></a>哈希树</h3><p>通过哈希算法计算值的键，以键值对的方式存储数据。</p>\n<p><img src=\"/fage789/rufeng.github.io/fage789/rufeng.github.io/post/Mysql%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91/哈希树.bmp\" alt=\"哈希树.bmp\"></p>\n<p>可以看到插入了<code>[0，1，2，3，4，55]</code>，而<code>[3，55]</code>的<strong>哈希值</strong>相同而放在<strong>同一键</strong>下，并以<strong>链式</strong>的方式存储。这种方式查找单个值十分迅速，只需反向计算出哈希值就能定位到键并通过键找到值。但是因为<strong>哈希值是没有顺序的所以没有办法进行范围查找</strong>，而且有可能有些<strong>值得到的哈希值相同</strong>。</p>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>平衡树指的是，任意节点的子树的高度差都小于等于1。</p>\n<p><img src=\"/fage789/rufeng.github.io/fage789/rufeng.github.io/post/Mysql%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91/平衡二叉树.bmp\" alt=\"平衡二叉树.bmp\"></p>\n<p>可以看到插入<code>0~10</code>，生成了一棵深度为三的树，当我们查询3的时候需要查询2次:</p>\n<ul>\n<li><code>3 &lt; 4</code>进入到左边节点向下查询</li>\n<li><code>3 &gt; 2</code>进入到右边节点向下查询，右边节点等于三，则停止</li>\n</ul>\n<p>因此查询速度是由这棵树的深度决定，<strong>数据量越大则深度越大，速度越慢，且范围查找十分困难</strong>。</p>\n<h3 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h3><p>是一个节点可以存储超过2个元素、可以拥有超过2个子节点的多路平衡查找树</p>\n<p><img src=\"/fage789/rufeng.github.io/fage789/rufeng.github.io/post/Mysql%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91/B树.bmp\" alt=\"B树.bmp\"></p>\n<p>可以看到插入<code>0 ~ 14</code>，生成了一棵深度为三的树，当我们查询3的时候需要查询2次，<br>搜索方式也是和平衡二叉树相似</p>\n<ol>\n<li>先在节点内部从小到大（从左到右）开始搜索元素，如果命中，搜索结束;</li>\n<li>如果未命中，再去对应的子节点中搜索元素，然后重复步骤</li>\n</ol>\n<p>它的缺点是<strong>每个节点都存储了索引和业务数据</strong>，业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及<code>CPU</code>高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，现在却要多次才能加载完。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃，<strong>如果十分占内存可能每个节点能存储的数据相当少导致深度变大，速度变慢，且范围查找也十分不方便</strong></p>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><p>B+ 树就是为了拆分索引数据与业务数据的平衡多叉树。相比B树非叶子节点不记录业务数据，且叶子节点根据顺序互相链接。</p>\n<p><img src=\"/fage789/rufeng.github.io/fage789/rufeng.github.io/post/Mysql%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91/B+树.bmp\" alt=\"B+树.bmp\"></p>\n<p>可以看到插入<code>0 ~ 10</code>，生成了一棵深度为三的树，当我们查询3的时候需要查询2次，因为根节点和子节点不存储业务数据，则非叶子节点能够存储的元素就相当多，保证深读不会多大，且叶子节点会互相链接，范围查找就相当方便，例如要查找 <code>&gt;2</code>的数据，只需<strong>找到2并根据链接向右查找</strong>。</p>\n<p>Mysql的主键树如图：</p>\n<p><img src=\"/fage789/rufeng.github.io/fage789/rufeng.github.io/post/Mysql%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91/MysqlB+树.bmp\" alt=\"MysqlB+树.bmp\"></p>\n<p>可以看到树<strong>从上到下从左到右都是有顺序的</strong>，所以这也是Mysql的ID优先使用主键自增，而不使用UUID。因为使用UUID当遇到插入、删除时，可能需要重新排序，而到导致需要修改整颗，十分耗时。如果Mysql里没有创建ID，则会默认创建一个<strong>隐式主键Id</strong>，用来创建B+树，而创建其它索引时，也会根据此索引创建B+树，但是叶子节点存储的业务数据是主键，所以根据索引查找数据时，将会查找两次树，一次在索引B+树上找到主键，再在主键B+树上查找数据。而这颗索引树也是会消耗空间和维护成本，所以不要在不必要的时候去创建索引，而且索引也尽量最小化。 </p>\n<h2 id=\"Mysql的B-树总结\"><a href=\"#Mysql的B-树总结\" class=\"headerlink\" title=\"Mysql的B+树总结\"></a>Mysql的B+树总结</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>B+树从左至右，从上到下索引都是按照一定的顺序做排列，提高了查询速度</li>\n<li>非叶子节点不存储业务数据，大大增加了非叶子节点存储的元素，减少了树的深度，提高了查询速度</li>\n<li>叶子节点会根据顺序相互链接，提高了范围查找的方便性</li>\n<li>主键不使用UUID，使用自增ID，减少了插入、删除时需要重排，导致修改整颗树的可能性，减少了维护成本</li>\n<li>Mysql的表人为的不创建主键， Mysql会隐式的创建主键</li>\n<li>创建的索引会创建一颗索引B+树，消耗空间且提高了维护成本，所以非必要时不要创建索引</li>\n<li>索引B+树叶子节点不存业务数据只存储主键，会根据主键再次查找数据</li>\n</ol></blockquote>\n","text":"引言通过分析哈希索引、平衡二叉树、B树、B+树来判断Mysql为什么使用B+树。 其中文章中使用的数据结构可视化地址能够更好的帮助大家了解这四种索引方式。 哈希树通过哈希算法计算值的键，以键值对的方式存储数据。 可以看到插入了[0，1，2，3，4，55]，而[3，55]的哈希值相...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":2,"path":"api/categories/Mysql.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":2,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E6%A0%91\"><span class=\"toc-text\">哈希树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">平衡二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B%E6%A0%91\"><span class=\"toc-text\">B树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-%E6%A0%91\"><span class=\"toc-text\">B+树</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Mysql%E7%9A%84B-%E6%A0%91%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">Mysql的B+树总结</span></a></li></ol>","author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"mapped":true,"prev_post":{"title":"Mysql索引失效的几种情况","uid":"44c25000734936b0a1dbcbaacbd8e114","slug":"Mysql索引失效的几种情况","date":"2022-06-14T03:30:06.000Z","updated":"2022-06-14T05:41:13.833Z","comments":true,"path":"api/articles/Mysql索引失效的几种情况.json","keywords":null,"cover":null,"text":"引言索引在我们使用Mysql数据库时可以极大的提高效率，然而有时候因为使用上的问题导致索引失效。现在我们看看有哪几种情况索引失效。 转换索引数据类型不一致SELECT * FROM user WHERE height&#x3D; 180; &#x2F;&#x2F; 其中heigh...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":2,"path":"api/categories/Mysql.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":2,"path":"api/tags/MySQL.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}}},"next_post":{"title":"Java Optional的使用","uid":"135ff637d6fd3260ea45b1df53f84b3e","slug":"Java Optional的使用","date":"2022-06-08T06:30:06.000Z","updated":"2022-06-08T06:58:05.596Z","comments":true,"path":"api/articles/Java Optional的使用.json","keywords":null,"cover":null,"text":"引言Optional类是Java8为了解决null值判断问题，借鉴google guava类库的Optional类而引入的一个同名Optional类，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerExc...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"java","slug":"java","count":4,"path":"api/categories/java.json"},{"name":"Optional","slug":"java/Optional","count":1,"path":"api/categories/java/Optional.json"}],"tags":[{"name":"java","slug":"java","count":4,"path":"api/tags/java.json"},{"name":"Optional","slug":"Optional","count":1,"path":"api/tags/Optional.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}}}}