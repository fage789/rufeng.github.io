{"title":"Java Stream 流式编程","uid":"21734e1cbf39a356733db81c004c61e6","slug":"Java Stream 流式编程","date":"2022-06-06T07:30:06.000Z","updated":"2022-06-07T10:23:32.433Z","comments":true,"path":"api/articles/Java Stream 流式编程.json","keywords":null,"cover":[],"content":"<h2 id=\"引言-2\">引言</h2>\n<p>流是<code>Java API</code>的新成员，它允许你以<strong>声明性方式</strong>处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的<strong>高级迭代器</strong>。此外，流还可以透明地并行处理，你无需写任何多线程代码了！</p>\n<h2 id=\"流创建\">流创建</h2>\n<h3 id=\"通过集合\">通过集合</h3>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 创建一个集合\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n&#x2F;&#x2F; 得到一个顺序流\nStream&lt;Integer&gt; stream &#x3D; list.stream();\n&#x2F;&#x2F; 得到一个并行了流\nStream&lt;Integer&gt; parallelStream &#x3D; list.parallelStream();</code></pre>\n<h3 id=\"通过数组\">通过数组</h3>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 先创建一个数组\nint[] arr &#x3D; new int[]&#123;1, 2, 3, 4, 5, 6&#125;;\n&#x2F;&#x2F; 使用数组Arrays工具类获取Stream流\nIntStream stream &#x3D; Arrays.stream(arr);</code></pre>\n<h3 id=\"通过of\">通过of</h3>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Stream&lt;Integer&gt; stream &#x3D; Stream.of(1,2,3,4,5,6);</code></pre>\n<h3 id=\"创建无限流\">创建无限流</h3>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 无限流之迭代方式\n&#x2F;&#x2F; 创建了10个元素从0到18, 第一个参数是初始值、第二个参数决定下一个生成值的规则\nStream&lt;Integer&gt; streamI &#x3D;  Stream.iterate(0, t -&gt; t + 2).limit(10);\n        \n&#x2F;&#x2F; 无限流之生成方式\n&#x2F;&#x2F; 创建了10个随机数\nStream&lt;Double&gt; streamG &#x3D;  Stream.generate(Math::random).limit(10);</code></pre>\n<h3 id=\"构造器模式\">构造器模式</h3>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Stream&lt;Integer&gt; stream &#x3D; Stream.&lt;Integer&gt;builder().add(1).add(2).build();\nstream.forEach(System.out::print);</code></pre>\n<h2 id=\"流的常用操作\">流的常用操作</h2>\n<h3 id=\"中间操作与终端操作\">中间操作与终端操作</h3>\n<p>java.util.stream.Stream中的Stream接口定义了许多操作。它们可以分为两大类。我们来看一下例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; names &#x3D; menu.stream() \n    .filter(d -&gt; d.getCalories() &gt; 300)\n    .map(Dish::getName) \n    .limit(3) \n    .collect(toList()); </code></pre>\n<p><img src=\"/post/Java%20Stream%20%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/%E6%B5%81%E6%93%8D%E4%BD%9C.jpg\" alt=\"流操作.png\"></p>\n<p>你可以看到两类操作：</p>\n<ul>\n<li><code>filter</code>、<code>map</code>和<code>limit</code>可以连成一条流水线；</li>\n<li><code>collect</code>触发流水线执行并关闭它。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以连接起来的流操作称为<em><strong>中间操作</strong></em>，关闭流的操作称为<em><strong>终端操作</strong></em>。</p></blockquote>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">警告</p>\n<p>使用终端操作代表消费流结束,想要重新消费必须重新构建流。</p>\n\n</div>\n<h3 id=\"常用操作API\">常用操作API</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>类型</th>\n<th>返回类型</th>\n<th>操作参数</th>\n<th>函数描述符</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>filter</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n<td>过滤</td>\n</tr>\n<tr>\n<td><code>distinct</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n<td>去重</td>\n</tr>\n<tr>\n<td><code>skip</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>long</code></td>\n<td></td>\n<td>跳过元素</td>\n</tr>\n<tr>\n<td><code>limit</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n<td>截短</td>\n</tr>\n<tr>\n<td><code>map</code></td>\n<td>中间</td>\n<td><code>Stream&lt;R&gt;</code></td>\n<td><code>Function&lt;T, R&gt;</code></td>\n<td><code>T -&gt; R</code></td>\n<td>映射</td>\n</tr>\n<tr>\n<td><code>flatMap</code></td>\n<td>中间</td>\n<td><code>Stream&lt;R&gt;</code></td>\n<td><code>Function&lt;T, Stream&lt;R&gt;&gt;</code></td>\n<td><code>T -&gt; Stream&lt;R&gt;</code></td>\n<td>展平</td>\n</tr>\n<tr>\n<td><code>sorted</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>Comparator&lt;T&gt;</code></td>\n<td>(<code>T, T) -&gt; int</code></td>\n<td>排序</td>\n</tr>\n<tr>\n<td><code>peek</code></td>\n<td>中间</td>\n<td><code>Stream&lt;T&gt;</code></td>\n<td><code>Consumer&lt;T&gt;</code></td>\n<td><code>T -&gt; void</code></td>\n<td>消费流中的每个元素，主要用于调试</td>\n</tr>\n<tr>\n<td><code>anyMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n<td>是否至少匹配一个元素</td>\n</tr>\n<tr>\n<td><code>noneMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n<td>是否匹配所有元素</td>\n</tr>\n<tr>\n<td><code>allMatch</code></td>\n<td>终端</td>\n<td><code>boolean</code></td>\n<td><code>Predicate&lt;T&gt;</code></td>\n<td><code>T -&gt; boolean</code></td>\n<td>是否没有任何元素匹配</td>\n</tr>\n<tr>\n<td><code>findAny</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n<td>查找所有元素</td>\n</tr>\n<tr>\n<td><code>findFirst</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td></td>\n<td></td>\n<td>查找第一个元素</td>\n</tr>\n<tr>\n<td><code>foreach</code></td>\n<td>终端</td>\n<td><code>void</code></td>\n<td><code>Consumer&lt;T&gt;</code></td>\n<td><code>T -&gt; void</code></td>\n<td>消费流中的每个元素并对其应用<code>Lambda</code>。这一操作返回<code>void</code></td>\n</tr>\n<tr>\n<td><code>collect</code></td>\n<td>终端</td>\n<td><code>R</code></td>\n<td><code>T -&gt; void</code></td>\n<td></td>\n<td>把流归约成一个集合，比如<code>List</code>、<code>Map</code> 甚至是<code>Integer</code></td>\n</tr>\n<tr>\n<td><code>reduce</code></td>\n<td>终端</td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td><code>BinaryOperator&lt;T&gt;</code></td>\n<td><code>(T, T) -&gt; T</code></td>\n<td>归约</td>\n</tr>\n<tr>\n<td><code>count</code></td>\n<td>终端</td>\n<td><code>long</code></td>\n<td></td>\n<td></td>\n<td>查找第一个元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实际场景\">实际场景</h3>\n<h4 id=\"筛选和切片\">筛选和切片</h4>\n<ul>\n<li><code>filter:</code> 根据传入的Predicate函数式接口, 返回一个包括所有符合条件元素的流</li>\n<li><code>distinct:</code> 返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流</li>\n<li><code>skip:</code> 返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流</li>\n<li><code>limit:</code> 该方法会返回一个不超过给定长度的流。如果流是有序的,则最多返回前n个元素</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 1, 3, 3, 2, 4, 6, 8); \nnumbers.stream() \n .filter(i -&gt; i % 2 &#x3D;&#x3D; 0) &#x2F;&#x2F; 过滤出偶数\n .distinct()              &#x2F;&#x2F; 相同的数字删除\n .skip(1)                 &#x2F;&#x2F; 跳过第一个元素\n .limit(2)                &#x2F;&#x2F; 取出前两个数\n .forEach(System.out::println); &#x2F;&#x2F; 4, 6  </code></pre>\n<h4 id=\"映射和展平\">映射和展平</h4>\n<ul>\n<li><code>map:</code> 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素</li>\n<li><code>flatMap:</code> 它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; words &#x3D; Arrays.asList(&quot;Hello&quot;,&quot;World&quot;);\nList&lt;String&gt; uniqueCharacters &#x3D; words.stream()\n        .map(w -&gt; w.split(&quot;&quot;))    &#x2F;&#x2F; 映射成一组字符数组\n        .flatMap(Arrays::stream)  &#x2F;&#x2F; 数组展平成一个数组\n        .distinct()               &#x2F;&#x2F; 字符去重\n        .collect(Collectors.toList());</code></pre>\n<p><img src=\"/post/Java%20Stream%20%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/%E6%98%A0%E5%B0%84%E5%92%8C%E5%B1%95%E5%B9%B3.png\" alt=\"映射和展平.png\"></p>\n<h4 id=\"查找和匹配\">查找和匹配</h4>\n<ul>\n<li><code>anyMatch:</code> 流中是否有一个元素能匹配给定的条件</li>\n<li><code>nonneMatch:</code> 流中是否没有一个元素能匹配给定的条件</li>\n<li><code>findAny:</code> 方法将返回当前流中的任意元素</li>\n<li><code>findFirst:</code> 方法将返回当前流中的第一个元素</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; anyMatch\nif(menu.stream().anyMatch(Dish::isVegetarian))&#123; \n    System.out.println(&quot;The menu is (somewhat) vegetarian friendly!!&quot;); \n&#125;\n\n&#x2F;&#x2F; nonneMatch\nboolean isHealthy &#x3D; menu.stream() \n    .noneMatch(d -&gt; d.getCalories() &gt;&#x3D; 1000);\n\n&#x2F;&#x2F; findAny \nOptional&lt;Dish&gt; dish &#x3D; menu.stream() \n    .filter(Dish::isVegetarian) \n    .findAny(); \n\n&#x2F;&#x2F; findFirst\nList&lt;Integer&gt; someNumbers &#x3D; Arrays.asList(1, 2, 3, 4, 5); \nOptional&lt;Integer&gt; firstSquareDivisibleByThree &#x3D; someNumbers.stream() \n    .map(x -&gt; x * x) \n    .filter(x -&gt; x % 3 &#x3D;&#x3D; 0) \n    .findFirst(); &#x2F;&#x2F; 9 </code></pre>\n<h4 id=\"归约和汇总\">归约和汇总</h4>\n<ul>\n<li><code>reduce:</code> reduce 操作可以实现从一组值中生成一个值</li>\n<li><code>max:</code> 获取最大值</li>\n<li><code>min:</code> 获取最小值</li>\n<li><code>count:</code> 获取总数</li>\n<li><code>Collectors.joining:</code> 字符串合并</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Integer&gt; nums &#x3D; Arrays.asList(1,4,5,6,78);\n\n&#x2F;&#x2F; max\nInteger max &#x3D; nums.stream().max(Integer::compare).get(); &#x2F;&#x2F; 78\n\n&#x2F;&#x2F; min\nInteger min &#x3D; nums.stream().min(Integer::compare).get(); &#x2F;&#x2F; 1\n\n&#x2F;&#x2F; count\nLong count &#x3D; nums.stream().count(); &#x2F;&#x2F; 5\n\n&#x2F;&#x2F; reduce 求和\nInteger sum &#x3D; nums.stream().reduce(Integer::sum).get(); &#x2F;&#x2F; 94\n\nList&lt;String&gt; names &#x3D; Arrays.asList(&quot;Zebe&quot;, &quot;Hebe&quot;, &quot;Mary&quot;, &quot;July&quot;, &quot;David&quot;);\n\n&#x2F;&#x2F; 字符串合并\n&#x2F;&#x2F; 拼接成 [x, y, z] 形式\nString result1 &#x3D; names.stream().collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;));\n&#x2F;&#x2F; 拼接成 x, y, z 形式\nString result2 &#x3D; names.stream().collect(Collectors.joining(&quot;,&quot;));\n&#x2F;&#x2F; 拼接成 xyz 形式\nString result3 &#x3D; names.stream().collect(Collectors.joining());</code></pre>\n<h4 id=\"分组和分区\">分组和分区</h4>\n<ul>\n<li><code>Collectors.groupingBy:</code> 对数据按一定规则分组</li>\n<li><code>Collectors.partitioningBy:</code> 分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函<br>\n数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Student&gt; stuList &#x3D; new ArrayList&lt;Student&gt;();\nStudent stu1 &#x3D; new Student(&quot;10001&quot;, &quot;孙权&quot;, &quot;1000101&quot;, 16, &#39;男&#39;);\nStudent stu2 &#x3D; new Student(&quot;10001&quot;, &quot;曹操&quot;, &quot;1000102&quot;, 16, &#39;男&#39;);\nStudent stu3 &#x3D; new Student(&quot;10002&quot;, &quot;刘备&quot;, &quot;1000201&quot;, 16, &#39;男&#39;);\nStudent stu4 &#x3D; new Student(&quot;10002&quot;, &quot;大乔&quot;, &quot;1000202&quot;, 16, &#39;女&#39;);\nStudent stu5 &#x3D; new Student(&quot;10002&quot;, &quot;小乔&quot;, &quot;1000203&quot;, 16, &#39;女&#39;);\nStudent stu6 &#x3D; new Student(&quot;10003&quot;, &quot;诸葛亮&quot;, &quot;1000301&quot;, 16, &#39;男&#39;);\n\n&#x2F;&#x2F; 按班级分组\nMap&lt;String, List&lt;Student&gt;&gt; collect &#x3D; stuList.stream()\n    .collect(Collectors.groupingBy(Student::getClassId)); &#x2F;&#x2F; &#123;&quot;10001&quot;:[], ...&#125;\n&#x2F;&#x2F; 或者使用Collectors.toMap按班级分组\nMap&lt;String, List&lt;Student&gt;&gt; collect1 &#x3D; stuList.stream()\n        .collect(Collectors.toMap(Student::getClassId,\n                stu -&gt; new ArrayList&lt;Student&gt;()&#123;&#123;add(stu);&#125;&#125;,\n                (a,b) -&gt; &#123;a.addAll(b);return a;&#125;));       &#x2F;&#x2F; &#123;&quot;10001&quot;:[], ...&#125;\n&#x2F;&#x2F; 按性别分组\nMap&lt;Boolean, List&lt;Student&gt;&gt; collect2 &#x3D; stuList.stream()\n    .collect(Collectors.partitioningBy(stu -&gt; \n    Objects.equals(&#39;男stu.getSex())));                    &#x2F;&#x2F; &#123;&quot;false&quot;:[], &quot;true&quot;: []&#125;\n</code></pre>\n<h2 id=\"收集器\">收集器</h2>\n<p>收集器非常有用，因为用它可以简洁而灵活地定义collect用来生成结果集合的标准。更具体地说，对流调用<br>\ncollect方法将对流中的元素触发一个归约操作（由Collector来参数化）。例如上述的<code>Collectors.groupingBy</code>、<code>Collectors.partitioningBy</code></p>\n<h3 id=\"常用Collectors类的静态工厂方法\">常用Collectors类的静态工厂方法</h3>\n<table>\n<thead>\n<tr>\n<th>工厂方法</th>\n<th>返回类型</th>\n<th>用于</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>toList</code></td>\n<td><code>List&lt;T&gt;</code></td>\n<td>把流中所有项目收集到一个 <code>List</code></td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>List&lt;Dish&gt; dishes = menuStream.collect(toList());</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>toSet</code></td>\n<td><code>Set&lt;T&gt;</code></td>\n<td>把流中所有项目收集到一个 <code>Set</code>，删除重复项</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>：Set&lt;Dish&gt; dishes = menuStream.collect(toSet());</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>toCollection</code></td>\n<td><code>Collection&lt;T&gt;</code></td>\n<td>把流中所有项目收集到给定的供应源创建的集合</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>java Collection&lt;Dish&gt; dishes = menuStream.collect(toCollection(), ArrayList::new);</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>counting</code></td>\n<td><code>Long</code></td>\n<td>计算流中元素的个数</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>long howManyDishes = menuStream.collect(counting());</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>summingInt</code></td>\n<td><code>Integer</code></td>\n<td>对流中项目的一个整数属性求和</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>int totalCalories = menuStream.collect(summingInt(Dish::getCalories));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>averagingInt</code></td>\n<td><code>Double</code></td>\n<td>计算流中项目 <code>Integer</code> 属性的平均值</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>double avgCalories = menuStream.collect(averagingInt(Dish::getCalories));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>summarizingInt</code></td>\n<td><code>IntSummaryStatistics</code></td>\n<td>收集关于流中项目 <code>Integer</code> 属性的统计值，例如最大、最小、总和与平均值</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>joining</code></td>\n<td><code>String</code></td>\n<td>连接对流中每个项目调用 toString 方法所生成的字符串</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>String shortMenu = menuStream.map(Dish::getName).collect(joining(&quot;, &quot;));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>maxBy</code></td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td>一个包裹了流中按照给定比较器选出的最大元素的 <code>Optional</code>，或如果流为空则为 <code>Optional.empty()</code></td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>Optional&lt;Dish&gt; fattest = menuStream.collect(maxBy(comparingInt(Dish::getCalories)));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>minBy</code></td>\n<td><code>Optional&lt;T&gt;</code></td>\n<td>一个包裹了流中按照给定比较器选出的最小元素的 <code>Optional</code>，或如果流为空则为 <code>Optional.empty()</code></td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>Optional&lt;Dish&gt; lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories)));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>reducing</code></td>\n<td>归约操作产生的类型</td>\n<td>从一个作为累加器的初始值开始，利用 <code>BinaryOperator</code> 与流中的元素逐个结合，从而将流归约为单个值</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>collectingAndThen</code></td>\n<td>转换函数返回的类型</td>\n<td>包裹另一个收集器，对其结果应用转换函数</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>groupingBy</code></td>\n<td><code>Map&lt;K, List&lt;T&gt;&gt;</code></td>\n<td>根据项目的一个属性的值对流中的项目作问组，并将属性值作为结果 <code>Map</code> 的键</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>Map&lt;Dish.Type,List&lt;Dish&gt;&gt; dishesByType = menuStream.collect(groupingBy(Dish::getType));</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>partitioningBy</code></td>\n<td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td>\n<td>根据对流中每个项目应用谓词的结果来对项目进行分区</td>\n</tr>\n<tr>\n<td><strong>使用示例:</strong> <code>Map&lt;Boolean,List&lt;Dish&gt;&gt; vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarian))</code></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n","feature":true,"text":"引言 流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，你无需写任何多线程代码了！ 流创建 通过集合 &#x2F;&#x2F; 创建一个集...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"java","slug":"java","count":3,"path":"api/categories/java.json"},{"name":"Stream","slug":"java/Stream","count":1,"path":"api/categories/java/Stream.json"},{"name":"流式编程","slug":"java/Stream/流式编程","count":1,"path":"api/categories/java/Stream/流式编程.json"}],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"},{"name":"Stream","slug":"Stream","count":1,"path":"api/tags/Stream.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80-2\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">流创建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E9%9B%86%E5%90%88\"><span class=\"toc-text\">通过集合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">通过数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%BF%87of\"><span class=\"toc-text\">通过of</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%97%A0%E9%99%90%E6%B5%81\"><span class=\"toc-text\">创建无限流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">构造器模式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%81%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">流的常用操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">中间操作与终端操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9CAPI\"><span class=\"toc-text\">常用操作API</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">实际场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AD%9B%E9%80%89%E5%92%8C%E5%88%87%E7%89%87\"><span class=\"toc-text\">筛选和切片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%A0%E5%B0%84%E5%92%8C%E5%B1%95%E5%B9%B3\"><span class=\"toc-text\">映射和展平</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">查找和匹配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">归约和汇总</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%BB%84%E5%92%8C%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">分组和分区</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">收集器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8Collectors%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">常用Collectors类的静态工厂方法</span></a></li></ol></li></ol>","author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"mapped":true,"prev_post":{"title":"Java文档注释","uid":"c89fcf3f80f5323c4d2b7488e0aabc7d","slug":"Java文档注释","date":"2022-06-07T10:30:06.000Z","updated":"2022-06-07T12:43:41.020Z","comments":true,"path":"api/articles/Java文档注释.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":3,"path":"api/categories/java.json"},{"name":"注释","slug":"java/注释","count":1,"path":"api/categories/java/注释.json"}],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"},{"name":"注释","slug":"注释","count":1,"path":"api/tags/注释.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"feature":true},"next_post":{"title":"Java函数式编程","uid":"2b987db277ec8f53b5baaa150ea429a6","slug":"Java函数式编程","date":"2022-05-31T13:30:06.000Z","updated":"2022-06-07T12:54:16.431Z","comments":true,"path":"api/articles/Java函数式编程.json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"java","slug":"java","count":3,"path":"api/categories/java.json"},{"name":"函数式编程","slug":"java/函数式编程","count":1,"path":"api/categories/java/函数式编程.json"}],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"},{"name":"函数式编程","slug":"函数式编程","count":1,"path":"api/tags/函数式编程.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"feature":true}}