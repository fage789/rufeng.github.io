{"title":"java开发手册一面向对象","uid":"d1bd2738cb3df5b91e8dbed191b9a6e0","slug":"Java开发手册—面向对象","date":"2022-07-18T15:30:06.000Z","updated":"2022-09-11T02:08:40.988Z","comments":true,"path":"api/articles/Java开发手册—面向对象.json","keywords":null,"cover":"/logo/27524ac7880511ebb6edd017c2d2eca2.jpg","content":"<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><p>此文章根据书籍《码出高效：Java开发手册》整理的读后笔记。仅交流学习使用。</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>面向对象编程<code>(ec -Ori te Programming, OOP)</code>是划时代的编程思想变革，推动了高级语言的快速发展和工业化进程。<code>OOP</code>的<strong><em>抽象</em></strong>、<strong><em>封装</em></strong>、<strong><em>继承</em></strong>、<strong><em>多态</em></strong>的理念使软件大规模化成为可能，有效地<strong>降低了软件开发成本、维护成本和复用成本</strong>。面向对象编程思想完全不同于传统的面向过程编程思想，使大型软件的开发就像措积木样隔离可控、高效简单 是当今编程领域的一股势不可当的潮流。 <code>OOP</code>实践了软件工程的三个主要目标<strong>可维护性、可重用性和可扩展性</strong>。甚至<code>JavaScript</code>从<code>ES6</code>后也开始加入<code>class</code>等关键词，朝<code>OOP</code>靠拢。</p>\n<h2 id=\"OOP理念\"><a href=\"#OOP理念\" class=\"headerlink\" title=\"OOP理念\"></a>OOP理念</h2><p>传统意义上面向对象有三大特性<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。本书明确将<strong>抽象</strong>为面向对象的特性之一，支持面向对象“四大特性”的说法。</p>\n<h3 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h3><p><code>Java</code>之父<code>Gosling</code>设计的<code>Object</code>类，是任何类的默认父类，是对万事万物的抽象，高度概括了事物的自然行为和社会行为。我们都知道哲学的三大经典问题我是谁，我从哪里来，我到哪里去。在<code>Object</code>类中，这些问题都可以得到隐约的解答。</p>\n<ul>\n<li>我是谁: <code>getClass()</code>说明本质上是谁，而<code>toString()</code>是当前职位的名片。</li>\n<li>我从哪里里来: <code>Object()</code>构造方法是生产对象的基本步骤， <code>clone()</code>是繁殖对象的另一种方式</li>\n<li>我到哪里去: <code>finalize()</code>是在对象销毁时触发的方法。</li>\n<li>世界是否因你不同: <code>hashCode()</code>、<code>equals()</code>就是判断与其他元素是否相同的组方法。</li>\n<li>与他人枉何协调: <code>wait()</code>和<code>notify()</code>是对象间通信与协作的一组方法。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如<code>finalize()</code>方法在<code>JDK9</code>之后直接被标记为过时方法。而<code>wait()</code>和 <code>notify()</code>同步方式事实上已经被同步信号、锁、阻塞集合等取代。</p></blockquote>\n<h4 id=\"浅拷贝与深拷贝\"><a href=\"#浅拷贝与深拷贝\" class=\"headerlink\" title=\"浅拷贝与深拷贝\"></a>浅拷贝与深拷贝</h4><ul>\n<li>浅拷贝：只<strong>复制当前对象的所有基本数据类型，以及相应的引用变量</strong>，但<strong>没有复制引用变量指向的实际对象</strong>。</li>\n<li>彻底深拷贝：是在成功<code>clone</code>一个对象之后，此<strong>对象与母对象在任何引用路径上都不存在共享的实例对象</strong>，但是引用路径递归越深，则越接近JVM对象，且发现彻底深拷贝实现难度越大。</li>\n<li>深拷贝：介于浅拷贝和彻底深拷贝之间的都是一般深拷贝</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>慎用<code>Object.clone()</code>方法来拷贝对象，因为对象的<code>clone()</code>方法默认是浅拷贝，若想实现深拷贝，则需要覆写<code>clone()</code>方法实现引用对象的深度遍历式拷贝。作者认为彻底深拷贝是与深拷贝不同的，但是实际中我们会认为深拷贝就是彻底深拷贝。就例如0.999…无限循环小数和1(或者固定位数的0.99..)在数学里是不等的，但是在生活中为了方便我们会认为0.999…无限循环小数约等于1(或者固定位数的0.99..)，即两者是相等的。</p></blockquote>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><p>封装是在抽象基础上决定信息<strong>是否公开</strong>，以及<strong>公开等级</strong>，核心问题是<strong>以什么样的方式暴露哪些信息</strong>。<br>抽象是要找到<strong>属性</strong>和<strong>行为的共性</strong>，<strong>属性是行为的基本生产资料，具有一定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行</strong>，某些敏感方法或者外部不需要感知的复杂逻辑处理，一般也会进行封装。<strong>封装使面向对象的耦合度变弱，有利于维护</strong>。而在Java中就是通过设置属性为private或者其它访问等级，限制属性的访问，让外部只能通过getter/setter去访问属性。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>继承是<strong>面向对象编程技术的基石</strong>，允许创建具有逻辑等级结构的类体系形成一个继承树，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复用或增强复用，父类的能力通过这种方式赋予子类。继承把枯燥的代码世界变得更有层次感，更有扩展性，为多态打下语法基础。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>继承是<strong>is-a</strong>的关系。判断标准即是否符合<code>里氏代换原则(Liskov Substitution Principle, LSP)</code>。<code>LSP</code>是指任何父类能够出现的地方，子类都能够出现。从字面上很难深入理解，先打个比方警察在枪战片中经常说放下武器，把手举起来！而对面的匪徒们<strong>有的使用手枪</strong>，<strong>有的使用匕首</strong>，这些都是<strong>武器的子类</strong>。父类出现的地方，即“放下武器” 那么，放下手枪，是对的，放下匕首，也是对的。在实际代码环境中，<strong>如果父类引用直接使用子类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期</strong>，那么说明两个类之间符合<code>LSP</code>原则，可以使用继承关系。</p></blockquote>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个方法产生不同的运行结果，使同一个行为具有不同的表现形式。多态提升了对象的扩展能力和运行时的丰富想象力。而<strong>重写</strong>和<strong>重载</strong>就是多态的实现方式。</p>\n<h3 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h3><ul>\n<li>重写：是子类实现接口或者继承父类时，保持<strong>方法签名完全相同</strong>，<strong>实现不同的方法体</strong>，是<strong>垂直方向上行为的不同体现</strong>。是运行上的多态性。重写时遵循<strong>两同两小一大原则</strong>。<ul>\n<li>两同：方法名相同，参数列表相同</li>\n<li>两小：子类返回值类型小于等于父类返回值类型(返回值为基本数据类型时，必须相等);子类抛出的异常小于等于父类抛出的异常</li>\n<li>一大：子类访问控制修饰符大于等于父类访问控制修饰符</li>\n</ul>\n</li>\n<li>重载：<strong>方法名称相同</strong>但是<strong>参数类型或参数个数是不相同的</strong>，<strong>不考虑修饰符以及返回值</strong>，是<strong>水平上行为的不同体现</strong>。是编译上的多态性。</li>\n</ul>\n","feature":true,"text":"声明此文章根据书籍《码出高效：Java开发手册》整理的读后笔记。仅交流学习使用。 引言面向对象编程(ec -Ori te Programming, OOP)是划时代的编程思想变革，推动了高级语言的快速发展和工业化进程。OOP的抽象、封装、继承、多态的理念使软件大规模化成为可能，有...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"面向对象","slug":"面向对象","count":1,"path":"api/categories/面向对象.json"}],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OOP%E7%90%86%E5%BF%B5\"><span class=\"toc-text\">OOP理念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1\"><span class=\"toc-text\">抽象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">浅拷贝与深拷贝</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">封装</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99\"><span class=\"toc-text\">重载和重写</span></a></li></ol></li></ol>","author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"mapped":true,"prev_post":{"title":"InfluxDB1.0的入门","uid":"84a50db5bf041e6e7c87814a2cdda6c0","slug":"InfluxDB的入门","date":"2022-09-11T15:30:06.000Z","updated":"2022-09-11T02:14:43.245Z","comments":true,"path":"api/articles/InfluxDB的入门.json","keywords":null,"cover":null,"text":"下载安装InfluxDB下载地址：https://dl.influxdata.com/influxdb/releases/influxdb-1.5.4_windows_amd64.zip 下载完成后修改influxdb.conf信息 将[meta]里的dir修改为自己的地址 将[...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"InfluxDB","slug":"InfluxDB","count":1,"path":"api/categories/InfluxDB.json"}],"tags":[{"name":"InfluxDB","slug":"InfluxDB","count":1,"path":"api/tags/InfluxDB.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"feature":true},"next_post":{"title":"Mysql索引失效的几种情况","uid":"44c25000734936b0a1dbcbaacbd8e114","slug":"Mysql索引失效的几种情况","date":"2022-06-14T03:30:06.000Z","updated":"2022-06-14T05:41:13.833Z","comments":true,"path":"api/articles/Mysql索引失效的几种情况.json","keywords":null,"cover":null,"text":"引言索引在我们使用Mysql数据库时可以极大的提高效率，然而有时候因为使用上的问题导致索引失效。现在我们看看有哪几种情况索引失效。 转换索引数据类型不一致SELECT * FROM user WHERE height&#x3D; 180; &#x2F;&#x2F; 其中heigh...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Mysql","slug":"Mysql","count":2,"path":"api/categories/Mysql.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":2,"path":"api/tags/MySQL.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"feature":true}}