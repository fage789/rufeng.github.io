{"title":"分布式锁的使用","uid":"eb06ef93065c8037d3e339961454164b","slug":"分布式锁的使用","date":"2022-10-11T15:30:06.000Z","updated":"2022-11-04T07:43:06.876Z","comments":true,"path":"api/articles/分布式锁的使用.json","keywords":null,"cover":null,"content":"<h2 id=\"引言-8\">引言</h2>\n<p>分布式锁的作用就是在分布式系统中解决多个机器之间共享资源的排他性。而只要能够解决锁的排他性、可重入性、锁的获取与释放的方法、锁的失效机制及避免死锁。则就可以作为分布式锁使用</p>\n<h3 id=\"使用Mysql作为分布式锁\">使用Mysql作为分布式锁</h3>\n<p>要实现分布式锁，最简单的方式就是直接创建一张锁表，然后通过操作该表中的数据来实现加锁和解锁。当要锁住某个方法或资源时，就向该表插入一条记录，表中设置方法名为唯一键，这样多个请求同时提交数据库时，只有一个操作可以成功，判定操作成功的线程获得该方法。<br>\n创建这样的一张表</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">CREATE TABLE &#96;method_lock&#96; (\n    &#96;id&#96; INT(11) NOT NULL AUTO_INCREMENT COMMENT &#39;自增id&#39;,\n    &#96;method_name&#96; VARCHAR(64) NOT NULL COMMENT &#39;方法名&#39;,\n    &#96;method_desc&#96; VARCHAR(1024) NOT NULL COMMENT &#39;方法描述&#39;,\n    &#96;create_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n    &#96;update_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,\n    PRIMARY KEY (&#96;id&#96;),\n    UNIQUE INDEX &#96;uniq_method_name&#96; (&#96;method_name&#96;)\n)\nCOMMENT&#x3D;&#39;分布式锁&#39;\nCOLLATE&#x3D;&#39;utf8_general_ci&#39;\nENGINE&#x3D;InnoDB;</code></pre>\n<p>加锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">insert into method_lock(method_name, method_desc) values(&quot;methodName&quot;, &quot;desc&quot;);\n</code></pre>\n<p>解锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">delete from method_lock where method_name &#x3D; &quot;methodName&quot;;</code></pre>\n<p>以上：</p>\n<ol>\n<li>我们利用数据库将<code>method_name</code>做了唯一约束保证了排他性。</li>\n<li>要使用锁变为可重入的，则在数据库表中加个字段<code>(thread_id)</code>，记录当前获得锁的机器的主机信息和线程信息，获取锁的时候先查询数据库，如果已经获取了则直接分配给他就可以。</li>\n<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。可以让数据库记录失效时间，使用定时任务清理。</li>\n<li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。可以循环多次去获取。</li>\n</ol>\n<h4 id=\"总结-2\">总结</h4>\n<p>数据库实现分布式锁的优点：</p>\n<ul>\n<li>直接借助数据库，容易理解</li>\n</ul>\n<p>数据库实现分布式锁的缺点：</p>\n<ul>\n<li>因为数据库本身的缺陷会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</li>\n<li>操作需要一定的开销，性能问题需要考虑</li>\n</ul>\n<h3 id=\"使用redis作为分布式锁\">使用redis作为分布式锁</h3>\n<p>在使用redis做分布式锁一般使用<code>setnx</code> + <code>expire</code>命令，即先用<code>setnx</code>来抢锁，如果抢到之后，再用<code>expire</code>给锁设置一个过期时间，防止锁忘记了释放。<br>\n代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if（jedis.setnx(key_resource_id,lock_value) &#x3D;&#x3D; 1）&#123; &#x2F;&#x2F;加锁\n    expire（key_resource_id，100）; &#x2F;&#x2F;设置过期时间\n    try &#123;\n        do something  &#x2F;&#x2F;业务请求\n    &#125;catch()&#123;\n  &#125;\n  finally &#123;\n       jedis.del(key_resource_id); &#x2F;&#x2F;释放锁\n    &#125;\n&#125;</code></pre>\n<p>但是这个方案中<code>setnx</code> + <code>expire</code>命令并不是原子操作。为了保证原子性我们可以使用<code>lu</code>脚本或者<code>SET</code>的扩展命令<code>(SET EX PX NX)</code></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SET key value[EX seconds][PX milliseconds][NX|XX]</p>\n<blockquote>\n<p>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。<br>\nEX seconds :设定key的过期时间，时间单位是秒。<br>\nPX milliseconds: 设定key的过期时间，单位为毫秒<br>\nXX: 仅当key存在时设置值</p></blockquote>\n</blockquote>\n<p>代码如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if（jedis.set(key_resource_id, lock_value, &quot;NX&quot;, &quot;EX&quot;, 100s) &#x3D;&#x3D; 1）&#123; &#x2F;&#x2F;加锁\n    try &#123;\n        do something  &#x2F;&#x2F;业务处理\n    &#125;catch()&#123;\n  &#125;\n  finally &#123;\n       jedis.del(key_resource_id); &#x2F;&#x2F;释放锁\n    &#125;\n&#125;</code></pre>\n<ol>\n<li>此时该方案的锁如果要保证可重入的，则<code>set</code>命令里需要加入<strong>线程ID</strong>，既可以保证只用加锁的线程能从删除也保证了锁的可重入性。<code>Redisson</code>框架中已经帮我们实现了这种功能</li>\n<li>有可能业务没执行完，超时时间到了，所以需要自动续期。<code>Redisson</code>框架中的<strong>看门狗</strong>帮我们实现了自动续期，以及续期上限</li>\n<li>如果redis是主从架构，则需要<code>Redisson</code>框架的<code>redlock</code></li>\n<li>为了提高性能可以使用读写锁分离、以及分段锁</li>\n</ol>\n<h3 id=\"Zookeeper实现分布式锁\">Zookeeper实现分布式锁</h3>\n<p><code>Zookeeper</code>一般使用临时顺序节点加<code>watch</code>监听器的方式实现分布式锁。比如客户端A创建临时节点<code>node001</code>,客户端A发现<code>node001</code>是临时顺序节点里最小的则获得锁，客户端B创建临时节点<code>node002</code>,发现<code>node002</code>不是最小节点，则客户端B开始等待，并在<code>node001</code>上创建监听器，当<code>node001</code>删除时，监听器通知客户端B，则客户端B获取到锁。</p>\n","feature":true,"text":"引言 分布式锁的作用就是在分布式系统中解决多个机器之间共享资源的排他性。而只要能够解决锁的排他性、可重入性、锁的获取与释放的方法、锁的失效机制及避免死锁。则就可以作为分布式锁使用 使用Mysql作为分布式锁 要实现分布式锁，最简单的方式就是直接创建一张锁表，然后通过操作该表中的数...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"分布式","slug":"分布式","count":1,"path":"api/categories/分布式.json"}],"tags":[{"name":"分布式","slug":"分布式","count":1,"path":"api/tags/分布式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80-8\"><span class=\"toc-text\">引言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Mysql%E4%BD%9C%E4%B8%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">使用Mysql作为分布式锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93-2\"><span class=\"toc-text\">总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8redis%E4%BD%9C%E4%B8%BA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">使用redis作为分布式锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">Zookeeper实现分布式锁</span></a></li></ol></li></ol>","author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"InfluxDB1.0的入门","uid":"84a50db5bf041e6e7c87814a2cdda6c0","slug":"InfluxDB的入门","date":"2022-09-11T15:30:06.000Z","updated":"2022-09-11T02:31:47.834Z","comments":true,"path":"api/articles/InfluxDB的入门.json","keywords":null,"cover":null,"text":"下载安装InfluxDB 下载地址：https://dl.influxdata.com/influxdb/releases/influxdb-1.5.4_windows_amd64.zip 下载完成后修改influxdb.conf信息 将[meta]里的dir修改为自己的地址 将...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"InfluxDB","slug":"InfluxDB","count":1,"path":"api/categories/InfluxDB.json"}],"tags":[{"name":"InfluxDB","slug":"InfluxDB","count":1,"path":"api/tags/InfluxDB.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"feature":true}}