{"title":"Java函数式编程","uid":"2b987db277ec8f53b5baaa150ea429a6","slug":"Java函数式编程","date":"2022-05-31T13:30:06.000Z","updated":"2022-06-07T13:07:33.283Z","comments":true,"path":"api/articles/Java函数式编程.json","keywords":null,"cover":null,"content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>什么是函数式编程，即可以把方法当做参数或者返回值传递或引用。在JavaScript中函数式编程已经很常见，但是Java Function是不能作为参数引用，为此Java 8中提出了三个概念</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>Lambda 表达式，也可以称为闭包，但我更愿意称为定义函数的简写表达式</li>\n<li>方法引用，可以直接引用已有Java类或对象（实例）的方法或构造器</li>\n<li>函数式接口，一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</li>\n</ol></blockquote>\n<h2 id=\"Lambda-表达式\"><a href=\"#Lambda-表达式\" class=\"headerlink\" title=\"Lambda 表达式\"></a>Lambda 表达式</h2><p>java8之前函数的引用方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Arrays.sort(array, new Comparator&lt;String&gt;() {\n    public int compare(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n});</code></pre>\n<p>上述写法非常繁琐，从java8开始，我们可以使用Lambda表达式写。可以看出Lambda表达式是函数定义的简写方式，不用声明匿名类，JVM会自己帮我们做。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Arrays.sort(array, (String s1, String s2) -&gt; {\n    return s1.compareTo(s2);\n});</code></pre>\n<h3 id=\"Lambda表达式的基本语法\"><a href=\"#Lambda表达式的基本语法\" class=\"headerlink\" title=\"Lambda表达式的基本语法\"></a>Lambda表达式的基本语法</h3><p><code>(parameters) -&gt;{ statements; }</code></p>\n<p>Lambda的两个省略</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>当箭头左边只有一个参数时,可省略<code>()</code><br><code>a =&gt; {return a + 1;}</code></li>\n<li>当箭头右边只有一句话时,可省略<code>{}</code>与<code>return</code><br><code>(a, b) =&gt; a + b;</code></li>\n</ol></blockquote>\n<h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><ul>\n<li><code>Lambda</code>表达式只能引用标记了<code>final</code>的外层局部变量，这就是说不能在<code>Lambda</code>内部修改定义在域外的局部变量，否则会编译错误</li>\n<li><code>Lambda</code>表达式的局部变量可以不用声明为<code>final</code>，但是必须不可被后面的代码修改(即隐性的具有<code>final</code>的语义)</li>\n<li>在<code>Lambda</code>表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li>\n</ul>\n<p>例如：<br><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String first = \"\";  \nComparator &lt; String &gt; comparator = (first, second) -&gt; \n\tInteger.compare(first.length(), second.length()); // 编译会出错</code></pre></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int num = 1;  \nConverter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));\ns.convert(2);\nnum = 5;  \n// 报错信息：Local variable num defined in an enclosing scope must be final or effectively final</code></pre>\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用通过方法的名字来指向一个方法，可以使语音的构造更加紧凑，减少冗余代码，方法引用使用一对冒号。<br>对于Arrays.sort方法,第二个参数Comparator是一个单方法接口，除了可以传入Lambda表达式，我们还可以直接传入符合要求的方法引<code>Arrays.sort(array, String::compareTo);</code></p>\n<h3 id=\"方法引用的基本语法\"><a href=\"#方法引用的基本语法\" class=\"headerlink\" title=\"方法引用的基本语法\"></a>方法引用的基本语法</h3><h4 id=\"构造器的引用\"><a href=\"#构造器的引用\" class=\"headerlink\" title=\"构造器的引用\"></a>构造器的引用</h4><p>语法： <code>Class::new</code><br><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final Car car = Car.create( Car::new );\nfinal List&lt; Car &gt; cars = Arrays.asList( car );</code></pre></p>\n<h4 id=\"静态方法的引用\"><a href=\"#静态方法的引用\" class=\"headerlink\" title=\"静态方法的引用\"></a>静态方法的引用</h4><p>语法： <code>Class::static_method</code><br><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">cars.forEach( Car::collide );</code></pre></p>\n<h4 id=\"特定类的任意对象的方法引用\"><a href=\"#特定类的任意对象的方法引用\" class=\"headerlink\" title=\"特定类的任意对象的方法引用\"></a>特定类的任意对象的方法引用</h4><p>语法： <code>Class::method</code><br><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">cars.forEach( Car::repair );</code></pre></p>\n<h4 id=\"特定对象的方法引用\"><a href=\"#特定对象的方法引用\" class=\"headerlink\" title=\"特定对象的方法引用\"></a>特定对象的方法引用</h4><p>语法： <code>instance::method</code><br><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final Car police = Car.create( Car::new );\ncars.forEach( police::follow );</code></pre></p>\n<h2 id=\"函数式接口\"><a href=\"#函数式接口\" class=\"headerlink\" title=\"函数式接口\"></a>函数式接口</h2><p>Lambda表达式、方法引用只是针对方法的简写与特殊方法引用的简写。那我们该如何将更加复杂的函数传递和引用呢？<br>那如何先声明一个可被传递或者引用的函数呢？使用@FunctionalInterface注解创建一个函数式接口即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FunctionalInterface\ninterface Functional {\n  String goodbye(String message);\n}</code></pre>\n<p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>函数式接口可以被隐式转换为 lambda 表达式。所以上面接口的实现方式可用Lambda表达式简写为</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Functional fx = message -&gt; System.out.println(\"Hello \" + message);\nfx.goodbye(\"world!!!\");</code></pre>\n<script type=\"math/tex; mode=display\">\\underbrace{message -> System.out.println(\"Hello \" + message)}_{函数} \\quad  \\underrightarrow{赋值} \\quad fx.goodbye</script><p>并通过<code>fx.goodbye(\"world!!!\")</code>调用。这也就是必须有且仅有一个抽象方法否则并不知道赋值给哪一个方法。</p>\n<h2 id=\"四大函数式接口\"><a href=\"#四大函数式接口\" class=\"headerlink\" title=\"四大函数式接口\"></a>四大函数式接口</h2><p>我们在使用函数式接口时，并不需要总是创建一个函数式接口。因为<code>JAVA8</code>已经为我们提供了常用的函数式接口。<br>|函数式接口名|方法名|作用|特征|示例|<br>|—|—|—|—|—|<br>|<code>Supplier</code>|<code>get()</code> <br> <code>getAs</code>类型()|生产者函数式接口|无参数 <br> 有返回值|<code>Supplier</code><t> <br> <code>BooleanSupplier</code> <br> <code>IntSupplier</code> <br> <code>LongSupplier</code> <br> <code>DoubleSupplier</code> |<br>|<code>Consumer</code>|<code>accept()</code>|消费者函数式接口|单个参数 <br> 无返回值|<code>Consumer</code> <br> <code>IntConsumer</code> <br> <code>LongConsumer</code> <br> <code>DoubleConsumer</code>|<br>|<code>Predicate</code>|<code>test()</code>|断言函数式接口|2 参数 <br> 返回布尔型|<code>Predicate</code> <br> <code>BiPredicate</code> <br> <code>IntPredicate</code> <br> <code>LongPredicate</code> <br> <code>DoublePredicate</code>|<br>|<code>Function</code>|<code>apply()</code> <br> <code>applyAs</code>类型()|功能函数式接口|单个参数 <br> 有返回值|<code>Function</code> <br> <code>IntFunction</code> <br> <code>LongFunction</code> <br> <code>DoubleFunction</code> <br> <code>ToIntFunction</code> <br> <code>ToLongFunction</code> <br> <code>ToDoubleFunction</code> <br> <code>IntToLongFunction</code> <br> <code>IntToDoubleFunction</code> <br> <code>LongToIntFunction</code> <br> <code>LongToDoubleFunction</code> <br> <code>DoubleToIntFunction</code> <br> <code>DoubleToLongFunction</code>|</t></p>\n<h3 id=\"supplier\"><a href=\"#supplier\" class=\"headerlink\" title=\"supplier\\\"></a>supplier\\<t\\></t\\></h3><p>生产者函数式接口,无参数，返回一个<code>T</code>类型结果。如果返回类型是基本类型可以使用BooleanSupplier、IntSupplier、LongSupplier、DoubleSupplier</p>\n<p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Supplier&lt;String&gt; supplier = String::new; \nSupplier&lt;Emp&gt; supplierEmp = Emp::new;\nEmp emp = supplierEmp.get();\nemp.setName(\"dd\");\n\nSystem.out.println(supplier.get()); // \"\"\nSystem.out.println(emp.getName());  // dd</code></pre>\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\\\"></a>Consumer\\<t\\></t\\></h3><p>接受一个<code>T</code>类型输入参数并且无返回。如果<code>T</code>是基本类型可以使用<code>IntConsumer</code>、<code>LongConsumer</code>、<code>DoubleConsumer</code>,如果需要输入两个参数使用<code>BiConsumer</code>,如果有一个类型是<code>Obj</code>,一个类型是基本类型可以使用<code>ObjIntConsumer</code>、<code>ObjLongConsumer</code>、<code>ObjDoubleConsumer</code></p>\n<p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Emp emp = new Emp();\nConsumer&lt;Emp&gt; nameConsumer = emp -&gt; System.out.println(emp.getName());  \nnameConsumer.accept(emp); // 打印学生名字</code></pre>\n<h3 id=\"Predicate\"><a href=\"#Predicate\" class=\"headerlink\" title=\"Predicate\\\"></a>Predicate\\<t\\></t\\></h3><p>接受一个<code>T</code>类型输入参数并且返回布尔值。如果<code>T</code>是基本类型可以使用<code>IntPredicate</code>、<code>LongPredicate</code>、<code>DoublePredicate</code>,如果需要输入两个参数使用<code>BiPredicate</code>。</p>\n<p>示例<br><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Predicate&lt;Integer&gt; predicate = t -&gt; t &gt; 5;\nSystem.out.println(predicate.test(6)); // true </code></pre></p>\n<h3 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function<t,r></t,r></h3><p>接受一个<code>T</code>类型输入参数返回一个<code>R</code>类型参数。如果<code>T</code>是基本类型可以使用<br><code>IntFunction</code>、<code>LongFunction</code>、<code>DoubleFunction</code>,如果<code>R</code>是基本类型<code>ToIntFunction</code>、<code>ToLongFunction</code>、<code>ToDoubleFunction</code>,如果<code>T</code>和<code>R</code>都是基本类型可以使用<code>IntToLongFunction</code>、<code>IntToDoubleFunction</code>、<code>LongToIntFunction</code>、<code>LongToDoubleFunction</code>、<code>DoubleToIntFunction</code>、<code>DoubleToLongFunction</code>,<br>如果需要传入两个参数可以使用<code>BiFunction</code>,要是<code>BiFunction</code>返回类型是基本类型可以使用<code>ToIntBiFunction</code>、<code>ToLongBiFunction</code>、<code>ToDoubleBiFunction</code>。</p>\n<p>示例<br><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Function&lt;Integer,Integer&gt; fuc = t -&gt; t - 1;\nSystem.out.println(fuc.apply(6)); // 5 </code></pre></p>\n<h3 id=\"其它函数式接口\"><a href=\"#其它函数式接口\" class=\"headerlink\" title=\"其它函数式接口\"></a>其它函数式接口</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数式接口名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Runnable</code></td>\n<td>不返回结果的线程</td>\n</tr>\n<tr>\n<td><code>Callable</code></td>\n<td>返回结果的线程</td>\n</tr>\n<tr>\n<td><code>UnaryOperator</code></td>\n<td>表示对同一类型的两个操作数的操作，产生与操作数相同类型的结果。</td>\n</tr>\n<tr>\n<td><code>BinaryOperator</code></td>\n<td>表示对单个操作数产生与其操作数相同类型的结果的操作。</td>\n</tr>\n<tr>\n<td><code>Comparator</code></td>\n<td>对同类型的两个参数作比较</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"函数组合\"><a href=\"#函数组合\" class=\"headerlink\" title=\"函数组合\"></a>函数组合</h2><p>函数组合（Function Composition）意为“多个函数组合成新函数”。它通常是函数式编程的基本组成部分。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>组合方法</th>\n<th>作用</th>\n<th>支持接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>andThen(argument)</code></td>\n<td>执行原操作,再执行参数操作</td>\n<td><code>Function</code> <br> <code>BiFunction</code> <br> <code>Consumer</code> <br> <code>BiConsumer</code> <br> <code>IntConsumer</code> <br> <code>LongConsumer</code> <br> <code>DoubleConsumer</code> <br> <code>UnaryOperator</code> <br> <code>IntUnaryOperator</code> <br> <code>LongUnaryOperator</code> <br> <code>DoubleUnaryOperator</code> <br> <code>BinaryOperator</code></td>\n</tr>\n<tr>\n<td><code>compose(argument)</code></td>\n<td>执行参数操作,再执行原操作</td>\n<td><code>Function</code> <br> <code>UnaryOperator</code> <br> <code>IntUnaryOperator</code> <br> <code>LongUnaryOperator</code> <br> <code>DoubleUnaryOperator</code></td>\n</tr>\n<tr>\n<td><code>and(argument)</code></td>\n<td>原<code>Predicate</code>函数式接口和参数<code>Predicate</code>函数式接口的短路逻辑与</td>\n<td><code>Predicate</code> <br> <code>BiPredicate</code> <br> <code>IntPredicate</code> <br> <code>LongPredicate</code> <br> <code>DoublePredicate</code></td>\n</tr>\n<tr>\n<td><code>or(argument)</code></td>\n<td>原<code>Predicate</code>函数式接口和参数<code>Predicate</code>函数式接口的短路逻辑或</td>\n<td><code>Predicate</code> <br> <code>BiPredicate</code> <br> <code>IntPredicate</code> <br> <code>LongPredicate</code> <br> <code>DoublePredicate</code></td>\n</tr>\n<tr>\n<td><code>negate()</code></td>\n<td>该<code>Predicate</code>函数式接口的逻辑非</td>\n<td><code>Predicate</code> <br> <code>BiPredicate</code> <br> <code>IntPredicate</code> <br> <code>LongPredicate</code> <br> <code>DoublePredicate</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>下例使用了<code>Function</code>里的<code>compose()</code>和<code>andThen()</code>。代码示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// functional/FunctionComposition.java\nimport java.util.function.*;\npublic class FunctionComposition {\n  static Function&lt;String, String&gt;\n    f1 = s -&gt; {\n      System.out.println(s);\n      return s.replace('A', '_');\n    },\n    f2 = s -&gt; s.substring(3),\n    f3 = s -&gt; s.toLowerCase(),\n    f4 = f1.compose(f2).andThen(f3);\n  public static void main(String[] args) {\n    System.out.println(\n      f4.apply(\"GO AFTER ALL AMBULANCES\"));\n  }\n}</code></pre>\n<p>输出结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">AFTER ALL AMBULANCES\n_fter _ll _mbul_nces</code></pre>\n<p>这里我们重点看正在创建的新函数<code>f4</code>。它调用<code>apply()</code>的方式与<code>Function</code>函数式接口几乎无异。<code>f4</code>组合后的新函数,<code>compose(f2)</code>表示<code>f2</code>的调用发生在<code>f1</code>之前,所以当<code>f1</code>获得字符串时，它已经被<code>f2</code>剥离了前三个字符。</p>\n<p>下例是Predicate的逻辑运算演示。代码示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// functional/PredicateComposition.java\nimport java.util.function.*;\nimport java.util.stream.*;\npublic class PredicateComposition {\n  static Predicate&lt;String&gt;\n    p1 = s -&gt; s.contains(\"bar\"),\n    p2 = s -&gt; s.length() &lt; 5,\n    p3 = s -&gt; s.contains(\"foo\"),\n    p4 = p1.negate().and(p2).or(p3);\n  public static void main(String[] args) {\n    Stream.of(\"bar\", \"foobar\", \"foobaz\", \"fongopuckey\")\n      .filter(p4)\n      .forEach(System.out::println);\n  }\n}</code></pre>\n<p>输出结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">foobar\nfoobaz</code></pre>\n<p><code>p4</code>是由<code>p1</code>、<code>p2</code>、<code>p3</code>组成,其判断逻辑是：如果字符串中不包含<code>bar</code>且长度小于5，或者它包含<code>foo</code>，则结果为<code>true</code>。<br>正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了<code>Java Stream</code>。首先，我创建了一个字符串对象的流，然后将每个对象传递给<code>filter()</code>操作。<code>filter()</code>使用<code>p4</code>的谓词来过滤。最后我们使用<code>forEach()</code>将<code>println</code>方法引用应用在每个留存的对象上。</p>\n<h2 id=\"柯里化和部分求值\"><a href=\"#柯里化和部分求值\" class=\"headerlink\" title=\"柯里化和部分求值\"></a>柯里化和部分求值</h2><p>将一个多参数的函数，转换为一系列单参数函数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// functional/CurryingAndPartials.java\nimport java.util.function.*;\npublic class CurryingAndPartials {\n   // 未柯里化:\n   static String uncurried(String a, String b) {\n      return a + b;\n   }\n   public static void main(String[] args) {\n      // 柯里化的函数:\n      Function&lt;String, Function&lt;String, String&gt;&gt; sum =\n         a -&gt; b -&gt; a + b; // [1]\n      System.out.println(uncurried(\"Hi \", \"Ho\"));\n      Function&lt;String, String&gt;\n        hi = sum.apply(\"Hi \"); // [2]\n      System.out.println(hi.apply(\"Ho\"));\n      // 部分应用:\n      Function&lt;String, String&gt; sumHi =\n        sum.apply(\"Hup \");\n      System.out.println(sumHi.apply(\"Ho\"));\n      System.out.println(sumHi.apply(\"Hey\"));\n   }\n}</code></pre>\n<p>输出结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Hi Ho\nHi Ho\nHup Ho\nHup Hey</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 这一连串的箭头很巧妙。注意，在函数接口声明中，第二个参数是另一个函数。<br><br> 柯里化的目的是能够通过提供单个参数来创建一个新函数，所以现在有了一个”带参函数”和剩下的”自由函数”(<code>free argument</code>)。实际上，你从一个双参数函数开始，最后得到一个单参数函数。</p></blockquote>\n<p>我们可以通过继续添加层级来柯里化一个三参数函数:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// functional/Curry3Args.java\nimport java.util.function.*;\npublic class Curry3Args {\n   public static void main(String[] args) {\n      Function&lt;String,\n        Function&lt;String,\n          Function&lt;String, String&gt;&gt;&gt; sum =\n            a -&gt; b -&gt; c -&gt; a + b + c;\n      Function&lt;String,\n        Function&lt;String, String&gt;&gt; hi =\n          sum.apply(\"Hi \");\n      Function&lt;String, String&gt; ho =\n        hi.apply(\"Ho \");\n      System.out.println(ho.apply(\"Hup\"));\n   }\n}</code></pre>\n<p>输出结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Hi Ho Hup</code></pre>\n<p>对于每一级的箭头级联(<code>Arrow-cascading</code>),你都会在类型声明周围包裹另一个<code>Function</code>。<br>处理基本类型和装箱时,请使用适当的函数式接口：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// functional/CurriedIntAdd.java\nimport java.util.function.*;\npublic class CurriedIntAdd {\n  public static void main(String[] args) {\n    IntFunction&lt;IntUnaryOperator&gt;\n      curriedIntAdd = a -&gt; b -&gt; a + b;\n    IntUnaryOperator add4 = curriedIntAdd.apply(4);\n    System.out.println(add4.applyAsInt(5));\n      }\n}</code></pre>\n<p>输出结果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">9</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在绝大多数多数的程序编写中,<code>Lambda</code>表达式和方法引用并配合<code>Java Stream</code>编程的方式的应用较多，但是函数式接口和柯里化的应用较少。个人觉得一方便绝大多数的开发还是CRUD和数据的梳理，另一方面只有在涉及到架构时或者编写通用工具方法时才有可能使用到<strong><em>函数式接口</em></strong>和<strong><em>柯里化</em></strong>。开发者在使用<strong><em>函数式接口</em></strong>和<strong><em>柯里化</em></strong>时需要从<strong><em>面向对象</em></strong>的思考方式做出部分的转变，以适应<strong><em>函数式编程</em></strong>。而且Java已经有了这么多年的历史，即使不使用函数式接口和柯里化也有成熟的解决方式，而市面上也并未有统一、成熟、全面的关于<strong><em>函数式接口</em></strong>和<strong><em>柯里化</em></strong>在Java开发中的规范要求去替代过去的方式。</p>\n","text":"引言什么是函数式编程，即可以把方法当做参数或者返回值传递或引用。在JavaScript中函数式编程已经很常见，但是Java Function是不能作为参数引用，为此Java 8中提出了三个概念 Lambda 表达式，也可以称为闭包，但我更愿意称为定义函数的简写表达式 方法引用，可...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"java","slug":"java","count":4,"path":"api/categories/java.json"},{"name":"函数式编程","slug":"java/函数式编程","count":1,"path":"api/categories/java/函数式编程.json"}],"tags":[{"name":"java","slug":"java","count":4,"path":"api/tags/java.json"},{"name":"函数式编程","slug":"函数式编程","count":1,"path":"api/tags/函数式编程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">Lambda 表达式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">Lambda表达式的基本语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">变量作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">方法引用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">方法引用的基本语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">构造器的引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">静态方法的引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E5%AE%9A%E7%B1%BB%E7%9A%84%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">特定类的任意对象的方法引用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%89%B9%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">特定对象的方法引用</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">函数式接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">四大函数式接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#supplier\"><span class=\"toc-text\">supplier\\</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Consumer\"><span class=\"toc-text\">Consumer\\</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Predicate\"><span class=\"toc-text\">Predicate\\</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Function\"><span class=\"toc-text\">Function</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">其它函数式接口</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88\"><span class=\"toc-text\">函数组合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%AF%E9%87%8C%E5%8C%96%E5%92%8C%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC\"><span class=\"toc-text\">柯里化和部分求值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}},"mapped":true,"prev_post":{"title":"Java Stream 流式编程","uid":"21734e1cbf39a356733db81c004c61e6","slug":"Java Stream 流式编程","date":"2022-06-06T07:30:06.000Z","updated":"2022-06-07T10:23:32.433Z","comments":true,"path":"api/articles/Java Stream 流式编程.json","keywords":null,"cover":[],"text":"引言流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，你无需写任何多线程代码了！ 流创建通过集合&#x2F;&#x2F; 创建一个集合 L...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"java","slug":"java","count":4,"path":"api/categories/java.json"},{"name":"Stream","slug":"java/Stream","count":1,"path":"api/categories/java/Stream.json"},{"name":"流式编程","slug":"java/Stream/流式编程","count":1,"path":"api/categories/java/Stream/流式编程.json"}],"tags":[{"name":"java","slug":"java","count":4,"path":"api/tags/java.json"},{"name":"Stream","slug":"Stream","count":1,"path":"api/tags/Stream.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}}},"next_post":{"title":"Lombok的使用一进阶篇","uid":"6a8b4d4d5ad2121dc1df69e7c613a802","slug":"Lombok的使用—进阶篇","date":"2022-05-25T15:30:06.000Z","updated":"2022-05-31T12:04:36.553Z","comments":true,"path":"api/articles/Lombok的使用—进阶篇.json","keywords":null,"cover":"/logo/Lombok的使用进阶篇.jpg","text":"进阶注解解析@SuperBuilder(实验性功能)是一个帮助类生成复杂的构建器 API。将循允许我们使用以下的方式去实例化对象，但是对继承的类的属性不会忽略,但是超类也必须使用此注解。使用方式可参照@Builder @Jacksonized(实验性功能)此注解是@Builder...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Lombok","slug":"Lombok","count":3,"path":"api/categories/Lombok.json"}],"tags":[{"name":"Lombok","slug":"Lombok","count":3,"path":"api/tags/Lombok.json"}],"author":{"name":"如峰","slug":"blog-author","avatar":"/logo/logo.jpg","link":"/","description":"程序员的秃头会迟到,但永远不会缺席","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/fgbts"}}}}}}